<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jheloper&#39;s Dev Log</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jheloper.github.io/"/>
  <updated>2020-06-21T20:09:35.863Z</updated>
  <id>https://jheloper.github.io/</id>
  
  <author>
    <name>Jheloper</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>객체지향의 사실과 오해(3장) 정리</title>
    <link href="https://jheloper.github.io/2020/06/object-oriented-facts-and-misunderstandings-03/"/>
    <id>https://jheloper.github.io/2020/06/object-oriented-facts-and-misunderstandings-03/</id>
    <published>2020-06-21T19:00:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/objected-oriented-facts-and-misunderstandings.jpg" alt></p><p>아래 내용은 조영호님의 “객체지향의 사실과 오해” 3장(타입과 추상화)를 읽고 개인적으로 정리한 내용들입니다.</p><h2 id="핵심-요약"><a href="#핵심-요약" class="headerlink" title="핵심 요약"></a>핵심 요약</h2><ul><li>추상화는 목적에 따라 불필요한 부분을 생략하거나 숨겨서 최대한 단순하게 만드는 것.</li><li>개념은 사물이나 객체에 적용할 수 있는 아이디어나 관념.</li><li>개념은 공통점을 기반으로 객체를 분류할 수 있는 일종의 체.</li><li>분류는 객체에 특정한 개념을 적용하는 작업.</li><li>개념의 3가지 관점 → 심볼, 내연, 외연.</li><li>심볼은 개념의 상징, 내연은 개념의 정의, 외연은 개념으로 분류된 객체들의 집합.</li><li>타입은 개념과 동일하다.</li><li>객체에서 중요한 것은 객체의 상태(데이터)가 아니라 객체의 행동.</li><li>동일한 행동을 수행할 수 있는 객체들은 동일한 타입으로 분류할 수 있다.</li><li>상태가 아니라 행동 중심으로 타입을 분류하는 것은 다형성, 캡슐화와도 관계가 있다.</li><li>일반화/특수화 관계를 결정하는 것은 객체의 상태가 아닌 행동이다.</li><li>타입과 클래스는 다르다. 타입은 객체를 분류하기 위한 개념이고, 클래스는 타입을 구현할 수 있는 메커니즘 중 하나일 뿐.</li></ul><h2 id="추상화를-통한-복잡성-극복"><a href="#추상화를-통한-복잡성-극복" class="headerlink" title="추상화를 통한 복잡성 극복"></a>추상화를 통한 복잡성 극복</h2><ul><li>현실은 복잡하며 예측 불가능한 혼돈 덩어리.<ul><li>사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화하는 전략을 따른다.</li></ul></li></ul><p>⇒ 복잡한 현실을 그대로 이해하기에는 인간의 인지 능력은 한계가 있기 때문에, 현실을 최대한 이해하기 쉽도록 단순화한다.</p><ul><li>추상화: 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 본질을 드러나게 하는 과정.</li><li>훌륭한 추상화는 목적에 부합하는 것이어야 한다.<ul><li>어떤 추상화도 의도된 목적이 아닌 다른 목적으로 사용된다면 오도될 수 있다.</li><li>추상화의 수준, 이익, 가치는 목적에 의존적이다.</li></ul></li></ul><p>⇒ 어떤 목적으로도 사용할 수 있는 “만능 추상화”는 없을 것이다.</p><ul><li>책에서의 추상화: 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 <strong><em>의도적으로 생략하거나 감춤으로써 복잡도를 극복</em></strong>하는 방법.</li><li>추상화는 2가지 차원에서 이뤄진다.<ol><li>구체적 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것.</li><li>중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것.</li></ol></li></ul><h2 id="객체지향과-추상화"><a href="#객체지향과-추상화" class="headerlink" title="객체지향과 추상화"></a>객체지향과 추상화</h2><ul><li>개념(concept): 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념.<ul><li>공통점을 기반으로 객체들을 묶기 위한 그릇.</li><li>공통점을 기반으로 객체를 분류할 수 있는 일종의 체.</li></ul></li><li>객체: 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다.<ul><li>개념이 객체에 적용됐을 때 객체를 개념의 인스턴스(instance)라고 한다.</li></ul></li><li>개념의 3가지 관점 → 심볼, 내연, 외연.<ul><li>심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭.</li><li>내연(intension): 개념의 완전한 정의, 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.</li><li>외연(extension): 개념에 속하는 모든 객체의 집합(set).</li></ul></li></ul><p>⇒ 쉽게 생각하면 심볼은 개념을 나타내는 이름이나 상징, 내연은 개념의 정의, 외연은 개념으로 분류된 객체들의 집합이라고 할 수 있다.</p><ul><li>분류(classification) : 객체에 특정한 개념을 적용하는 작업.<ul><li>객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정 집합의 멤버로 분류하고 있는 것이다.</li><li>어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.</li><li>적절한 분류 체계는 애플리케이션을 다루는 개발자의 머릿속에 객체를 쉽게 찾고 조작할 수 있는 정신적인 지도를 제공한다.</li></ul></li></ul><h2 id="타입"><a href="#타입" class="headerlink" title="타입"></a>타입</h2><ul><li>타입(type): (위에서 언급한)개념과 동일하다. 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다.<ul><li>어떤 객체에 타입을 적용할 수 있을 때 그 객체를 <strong><em>타입의 인스턴스</em></strong>라고 한다.</li><li>타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.</li></ul></li><li>컴퓨터 메모리의 세상에는 타입이라는 질서가 존재하지 않는다.<ul><li>타입이 없는 체계 안에서 모든 데이터는 일련의 비트열로 구성된다.</li></ul></li></ul><p>⇒ 기본적으로 컴퓨터 안의 데이터는 0과 1로 이뤄진 비트열이기 떄문에 이것만으로는 데이터가 무엇을 의미하는지 알기 힘들다.</p><ul><li>데이터를 목적에 따라 분류하기 시작하면서 프로그래밍 언어 안에는 서서히 타입 시스템(type system)이 자라나기 시작했다.<ul><li>타입 시스템의 목적은 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것이다.</li><li>타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것.</li></ul></li><li>데이터 타입에 관련된 2가지 중요한 사실<ol><li>타입은 데이터가 어떻게 사용되느냐에 관한 것. 어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정한다.</li><li>타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다. 개발자는 해당 데이터 타입을 사용하기 위해 단지 데이터 타입에 적용할 수 있는 연산자만 알고 있으면 된다.</li></ol></li><li>데이터 타입: 메모리 안에 저장된 데이터 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터.<ul><li>데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행 가능한지를 결정한다.</li><li>어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 그 데이터의 타입을 결정한다.</li></ul></li><li>데이터 타입과 객체지향의 타입 사이에 연관성?<ul><li>우리는 객체를 일종의 데이터처럼 사용한다.</li><li>객체를 타입에 따라 분류하고 타입에 이름을 붙이는 것은 새로운 데이터 타입을 선언하는 것과 같다.</li></ul></li><li>그렇다면 객체는 데이터인가?<ul><li>그렇지 않다. 객체에서 중요한 것은 객체의 행동이다.</li><li>상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념.</li><li>객체를 만들 때 가장 중요하게 고려해야 하는 것은 객체가 이웃 객체와 협력하기 위해 어떤 행동을 해야 할지를 결정하는 것.</li><li><strong><em>객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것</em></strong>이 객체지향 설계의 핵심.</li></ul></li></ul><p>⇒ 상태(데이터)를 중심으로 객체를 생각하지 말 것.</p><ul><li>객체의 타입에 관련된 2가지 중요한 사실(위의 “데이터 타입에 관련된 2가지 중요한 사실”과 비교)<ol><li>어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체의 행동. <strong><em>어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.</em></strong></li><li><strong><em>객체의 내부적인 표현은 외부로부터 철저하게 감춰진다</em></strong>. 객체의 행동을 수행할 수 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.</li></ol></li><li>객체의 내부 표현 방식이 다르더라도 어떤 객체들이 동일하게 행동한다면 그 객체들은 동일한 타입에 속한다.<ul><li>결과적으로 동일한 책임을 수행하는 일련의 객체는 동일한 타입에 속한다고 할 수 있다.</li><li>객체의 타입을 결정하는 것은 객체의 행동뿐이다.</li><li>객체가 <strong><em>어떤 데이터를 보유하고 있는지는 타입을 결정하는 데 아무런 영향도 미치지 않는다</em></strong>.</li></ul></li></ul><p>⇒ 객체의 타입에 대한 기준은 행동.</p><ul><li>동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 처리할 수 있다.<ul><li>다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다.</li><li>이것은 <strong><em>다형성(polymorphism)</em></strong>에 의미를 부여하며, 다형성이란 <strong><em>동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력</em></strong>을 뜻한다.</li></ul></li><li>데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다.<ul><li>따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. → <strong><em>캡슐화(encapsulation)</em>.</strong></li></ul></li><li>행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야 하는 데이터가 아니라 객체가 외부에 제공해야 하는 행동을 먼저 생각해야 한다.<ul><li><strong><em>데이터를 먼저 결정하고 객체의 책임을 결정하는 방법은 유연하지 못한 설계를 초래</em></strong>한다.</li><li><strong><em>책임 주도 설계(Responsibility driven design)</em></strong>라고 부르는 객체지향 설계 방법은 데이터를 먼저 생각하는 <strong><em>데이터 주도 설계(Data driven design)</em></strong> 방법의 단점을 개선하기 위해 고안됐다.</li></ul></li></ul><h2 id="타입의-계층"><a href="#타입의-계층" class="headerlink" title="타입의 계층"></a>타입의 계층</h2><ul><li>객체지향에서 <strong><em>일반화(generalization)/특수화(specialization) 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동</em></strong>이다.<ul><li>어떤 객체가 다른 객체보다 더 일반적인 상태를 표현하거나 더 특수한 상태를 표현한다고 해서 두 객체가 속하는 타입 간에 일반화/특수화 관계가 성립하는 것은 아니다.</li><li>두 타입 간에 일반화/특수화 관계가 성립하려면 한 타입이 다른 타입보다 더 특수하게 행동해야 하고 반대로 한 타입은 다른 타입보다 더 일반적으로 행동해야 한다.</li></ul></li></ul><p>⇒ 객체의 상태(데이터)에 따라 일반화/특수화 관계를 결정하는 것이 아니라, 객체의 행동에 따라 결정해야 한다.</p><ul><li>일반적인 타입은 특수한 타입에 비해 더 적은 수의 행동을 가지며 특수한 타입은 일반적인 타입에 비해 더 많은 행동을 가진다.<ul><li>단, 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있어야 한다.</li><li>타입의 내연을 의미하는 행동의 가짓수와 외연을 의미하는 집합의 크기는 서로 반비례한다.</li><li>일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지지만 더 큰 크기의 외연 집합을 가지고, 특수한 타입은 일반적인 타입보다 더 많은 수의 행동을 가지지만 더 적은 크기의 외연 집합을 가진다.</li></ul></li><li>좀 더 일반적인 타입을 <strong><em>슈퍼타입(supertype)</em></strong>, 좀 더 특수한 타입을 <strong><em>서브타입(subtype)</em></strong>이라고 한다.<ul><li><strong><em>어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행위적 호환성을 만족시켜야 한다</em></strong>. 일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야 한다.</li></ul></li></ul><p>⇒ SOLID 원칙 중 리스코프 치환 원칙.</p><h2 id="정적-모델"><a href="#정적-모델" class="headerlink" title="정적 모델"></a>정적 모델</h2><ul><li>타입을 사용하는 이유?<ul><li>인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 어렵기 때문이다.</li></ul></li><li>타입은 추상화다.<ul><li>타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다.</li><li>타입은 <strong><em>시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법</em></strong>.</li></ul></li><li>우리는 객체를 생각할 때 2가지 모델을 동시에 고려한다.<ol><li>동적 모델<ul><li>객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐. 이를 객체의 스냅샷(snapshot)이라고 한다.</li><li>UML에서 스냅샷은 “객체 다이어그램(object diagram)”이라고도 불린다. 스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것을 “동적 모델(dynamic model)”이라고 한다.</li></ul></li><li>정적 모델<ul><li>객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것이다.</li><li>일반적으로 이런 모델을 “타입 모델(type model)”이라고 하며 이 모델은 동적으로 변하는 객체의 상태가 아니라 객체가 속한 타입의 정적인 모습을 표현하기 때문에 “정적 모델(static model)”이라고도 한다.</li></ul></li></ol></li></ul><p>⇒ 동적 모델: 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 나타낸 모델.</p><p>⇒ 정적 모델: 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현한 모델.</p><ul><li>객체지향 애플리케이션을 설계하고 구현하기 위해서는 <strong><em>객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용</em></strong>해야 한다.</li><li>클래스(class)와 타입은 동일한 것이 아니다.<ul><li>타입은 객체를 분류하기 위해 사용하는 개념.</li><li><strong><em>클래스는 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나</em></strong>.</li></ul></li><li>객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이라는 사실을 기억할 것.<ul><li>객체를 분류하기 위해 타입을 결정한 후 타입을 구현할 수 있는 방법 중 1가지가 클래스.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/objected-oriented-facts-and-misunderstandings.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;아래 내용은 조영호님의 “객체지향의 사실과 오해” 3장(타입과 추상화)를 읽고 개인적으로 정리한 내용
      
    
    </summary>
    
    
      <category term="OOP" scheme="https://jheloper.github.io/tags/OOP/"/>
    
      <category term="객체지향" scheme="https://jheloper.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
      <category term="Book" scheme="https://jheloper.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>객체지향의 사실과 오해(2장) 정리</title>
    <link href="https://jheloper.github.io/2020/03/object-oriented-facts-and-misunderstandings-02/"/>
    <id>https://jheloper.github.io/2020/03/object-oriented-facts-and-misunderstandings-02/</id>
    <published>2020-03-30T14:30:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/objected-oriented-facts-and-misunderstandings.jpg" alt></p><p>아래 내용은 조영호님의 “객체지향의 사실과 오해” 2장(이상한 나라의 객체)를 읽고 개인적으로 정리한 내용들입니다.</p><h2 id="핵심-요약"><a href="#핵심-요약" class="headerlink" title="핵심 요약"></a>핵심 요약</h2><ul><li>객체는 상태, 행동, 식별자를 가진다.</li><li>객체의 상태는 특정 시점에 객체가 가지고 있는 정보의 집합.</li><li>객체의 행동은 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동.</li><li>객체의 식별자는 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티.</li><li>객체의 상태를 먼저 결정하고 행동을 나중에 결정하는 것보다는, 객체의 행동을 먼저 결정하고 상태를 나중에 결정하는 방법을 선택할 것.</li><li>객체지향 세계는 현실 세계의 모방이나 추상화보다는, 현실 세계의 은유에 가깝다.</li></ul><h2 id="객체지향과-인지-능력"><a href="#객체지향과-인지-능력" class="headerlink" title="객체지향과 인지 능력"></a>객체지향과 인지 능력</h2><p>많은 사람들이 객체지향을 직관적이고 이해하기 쉬운 패러다임이라고 말하는 이유? ⇒ 객체지향이 <strong><em>세상을 자율적이고 독립적인 객체들로 분해할 수 있는 인간의 기본적인 인지 능력</em></strong>에 기반을 두고 있기 때문.</p><p>그러나 현실 세계와 소프트웨어 세계 사이의 유사성은 여기까지, 왜? ⇒ 객체지향 패러다임의 목적은 <strong><em>현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것</em></strong>이기 때문에 소프트웨어 세계에서 살아가는 객체는 현실 세계에 존재하는 객체와는 전혀 다른 모습을 보이는 것이 일반적.</p><h2 id="객체-그리고-소프트웨어-나라"><a href="#객체-그리고-소프트웨어-나라" class="headerlink" title="객체, 그리고 소프트웨어 나라"></a>객체, 그리고 소프트웨어 나라</h2><p>객체의 다양한 특성을 효과적으로 설명하기 위해서는 <strong><em>객체를 상태, 행동, 식별자를 지닌 실체로 보는 것이 가장 효과적</em></strong>이다.</p><p>객체에 대한 정의? ⇒ 객체란 식별 가능한 개체 또는 사물. 객체는 <strong><em>자동차처럼 만질 수 있는 구체적인 사물</em></strong>일 수도 있고, <strong><em>시간처럼 추상적인 개념</em></strong>일 수도 있다. 객체는 <strong><em>구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태</em></strong>를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.</p><h2 id="상태"><a href="#상태" class="headerlink" title="상태"></a>상태</h2><p>과거에 발생한 행동의 이력을 통해 현재 발생한 행동의 결과를 판단하는 방식 ⇒ 일반적으로 복잡하고 번거로우며 이해하기 어렵다.</p><p>인간은 행동의 과정과 결과를 단순하게 기술하기 위해 <strong><em>상태</em></strong>라는 개념을 고안했는데, 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다.</p><p>숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓과 같은 단순한 값들은 객체가 아니다. 단순한 값들은 그 자체로 독립적인 의미를 가지기보다는 다른 객체의 상태를 표현하기 위해 사용된다. 이러한 단순한 값은 객체의 상태를 표현하기 위한 중요한 수단이다.</p><p>프로퍼티(property) ⇒ 모든 객체의 상태는 <strong><em>단순한 값과 객체의 조합으로 표현</em></strong>할 수 있는데 이때 <strong><em>객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티</em></strong>라고 한다.</p><p>속성과 링크</p><ul><li>속성(attribute) ⇒ 객체의 프로퍼티 중 단순한 값.</li><li>링크(link) ⇒ 객체의 프로퍼티 중 다른 객체를 참조하는 값.</li></ul><p>객체의 상태란? ⇒ <strong><em>특정 시점에 객체가 가지고 있는 정보의 집합</em></strong>으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다.</p><h2 id="행동"><a href="#행동" class="headerlink" title="행동"></a>행동</h2><p>객체가 취하는 행동은 객체 자신의 상태를 변경시킨다. <strong><em>객체의 행동에 의해 객체의 상태가 변경된다는 것은 행동이 부수 효과(side effect)를 초래</em></strong>한다는 것을 의미한다.</p><p>상태와 행동 사이의 관계</p><ul><li>객체의 행동은 상태에 영향을 받는다.</li><li>객체의 행동은 상태를 변경시킨다.</li></ul><p>행동을 서술하는 두 가지 관점</p><ul><li>상호작용이 현재의 상태에 어떤 방식으로 의존하는가.</li><li>상호작용이 어떻게 현재의 상태를 변경시키는가.</li></ul><p>객체의 행동으로 인해 발생하는 결과를 설명하는 두 가지 관점</p><ul><li>객체 자신의 상태 변경.</li><li>행동 내에서 협력하는 다른 객체에 대한 메시지 전송.</li></ul><p>객체가 다른 객체와 메시지를 통해서만 의사소통할 수 있다는 것을 기억할 것. 객체가 어떤 행동을 하도록 만드는 것은 객체가 외부로부터 수신한 메시지다.</p><p>객체의 행동이란? ⇒ <strong><em>외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동</em></strong>이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.</p><p>상태 캡슐화 ⇒ 객체는 상태를 감춰둔 채 외부로 노출하지 않는다. 객체가 <strong><em>외부에 노출하는 것은 행동</em></strong>뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.</p><p>상태를 캡슐화해야 하는 이유? ⇒ 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만들기 때문!</p><h2 id="식별자"><a href="#식별자" class="headerlink" title="식별자"></a>식별자</h2><p>값(value)과 객체의 가장 큰 차이점 ⇒ 값은 식별자를 가지지 않지만 객체는 식별자를 가진다는 점!</p><p>값의 상태는 변하지 않기 때문에 <strong><em>불변 상태(immutable state)</em></strong>를 가진다고 말한다. 값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스를 같은 것으로 판단한다.</p><p>객체는 시간에 따라 변경되는 상태를 포함하며 행동을 통해 상태를 변경한다. 따라서 객체는 <strong><em>가변 상태(mutable state)</em></strong>를 가진다고 말한다.</p><p>동등성과 동일성</p><ul><li>동등성(equality) ⇒ 상태를 이용해 두 값이 같은지 판단할 수 있는 성질.</li><li>동일성(identical) ⇒ 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질.</li></ul><p>객체의 식별자란? ⇒ <strong><em>어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티</em></strong>다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.</p><h2 id="객체의-특성"><a href="#객체의-특성" class="headerlink" title="객체의 특성"></a>객체의 특성</h2><ul><li>객체는 상태를 가지며 상태는 변경 가능하다.</li><li>객체의 상태를 변경시키는 것은 객체의 행동이다.<ul><li>행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.</li><li>행동의 순서가 실행 결과에 영향을 미친다.</li></ul></li><li>객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.</li></ul><h2 id="버트란드-마이어의-기계로서의-객체-비유"><a href="#버트란드-마이어의-기계로서의-객체-비유" class="headerlink" title="버트란드 마이어의 기계로서의 객체 비유"></a>버트란드 마이어의 기계로서의 객체 비유</h2><p>쿼리와 명령</p><ul><li>쿼리(query) ⇒ 일반적으로 객체의 상태를 조회하는 작업.</li><li>명령(command) ⇒ 객체의 상태를 변경하는 작업.</li></ul><p>객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.</p><p>버트란드 마이어가 제시한 기계(=객체)의 사용자는 명령 버튼을 누르거나 조회 버튼을 눌러서 사용한다. 어떤 사용자도 직접 기계를 열어 기계 내부의 상태에 직접 접근하려고 하지 않는다.</p><h2 id="행동이-상태를-결정한다"><a href="#행동이-상태를-결정한다" class="headerlink" title="행동이 상태를 결정한다"></a>행동이 상태를 결정한다</h2><p>상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 있어서 아래와 같은 나쁜 영향을 끼친다.</p><ol><li>상태를 먼저 결정할 경우 캡슐화가 저해된다.</li><li>객체를 협력자가 아닌 고립된 섬으로 만든다.</li><li>객체의 재사용성이 저하된다.</li></ol><p>객체는 다른 객체와 협력하기 위해 존재한다. 객체의 행동은 객체가 협력에 참여하는 유일한 방법이다. 따라서 <strong><em>객체가 적합한지를 결정하는 것은 그 객체의 상태가 아니라 행동</em></strong>이다.</p><p><strong><em>어떤 책임이 필요한가를 결정하는 과정이 전체 설계를 주도해야 한다.</em></strong> 책임 주도 설계는 협력이라는 문맥 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.</p><h2 id="은유와-객체"><a href="#은유와-객체" class="headerlink" title="은유와 객체"></a>은유와 객체</h2><p>많은 사람들이 객체지향을 현실 세계의 모방 또는 추상화라고 생각 ⇒ 그러나 객체지향 세계는 현실 세계의 단순한 모방이 아닌 전혀 다른 세계.</p><p>현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점? ⇒ 현실 속에서는 수동적인 존재일지라도 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것.</p><p>객체지향 세계와 현실 세계는 전혀 상관이 없는 것? ⇒ 상관이 없지는 않지만 모방이나 추상화보다 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 <strong><em>은유(metaphor)</em></strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/objected-oriented-facts-and-misunderstandings.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;아래 내용은 조영호님의 “객체지향의 사실과 오해” 2장(이상한 나라의 객체)를 읽고 개인적으로 정리한
      
    
    </summary>
    
    
      <category term="OOP" scheme="https://jheloper.github.io/tags/OOP/"/>
    
      <category term="객체지향" scheme="https://jheloper.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
      <category term="Book" scheme="https://jheloper.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>객체지향의 사실과 오해(1장) 정리</title>
    <link href="https://jheloper.github.io/2020/02/object-oriented-facts-and-misunderstandings-01/"/>
    <id>https://jheloper.github.io/2020/02/object-oriented-facts-and-misunderstandings-01/</id>
    <published>2020-02-23T14:00:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/objected-oriented-facts-and-misunderstandings.jpg" alt></p><p>아래 내용은 조영호님의 “객체지향의 사실과 오해” 1장(협력하는 객체들의 공동체)을 읽고 개인적으로 정리한 내용들입니다.</p><h2 id="핵심-요약"><a href="#핵심-요약" class="headerlink" title="핵심 요약"></a>핵심 요약</h2><ul><li>객체지향의 목표는 실세계의 모방이 아니다.</li><li>객체지향에서 중요한 3가지 개념 ⇒ 협력, 역할, 책임.</li><li>객체는 협력적이면서 자율적이어야 한다.</li><li>시스템의 기능은 객체의 협력으로 수행되며, 객체의 협력은 메시지를 주고 받으면서 이뤄진다.</li><li>메시지와 메서드의 분리를 통해서 객체의 외부와 내부를 분리하고, 이로써 객체의 자율성을 증진시킬 수 있다.</li><li>객체는 협력에 필요한 역할을 수행하며, 역할은 관련된 책임의 집합이다.</li><li>클래스에 포커스를 두지 말고 객체의 협력, 역할, 책임에 포커스를 두어라.</li></ul><h2 id="객체지향은-실세계의-모방"><a href="#객체지향은-실세계의-모방" class="headerlink" title="객체지향은 실세계의 모방?"></a>객체지향은 실세계의 모방?</h2><p>객체지향의 목표는 실세계를 모방하는 것이 아니라, 오히려 새로운 세계를 창조하는 것이다.</p><blockquote><p>“소프트웨어 시스템이 해결하려고 하는 실재는 잘해봐야 먼 친척밖에는 되지 않는다” by 버트란드 마이어.</p></blockquote><h2 id="실세계를-이용하여-객체지향을-설명하다"><a href="#실세계를-이용하여-객체지향을-설명하다" class="headerlink" title="실세계를 이용하여 객체지향을 설명하다"></a>실세계를 이용하여 객체지향을 설명하다</h2><p>실세계의 모방은 실무적 관점에서는 부적합하지만, 객체지향의 기본 사상을 이해하고 학습하는 데에는 매우 효과적이다.</p><p>객체지향에서 가장 중요한 개념 3가지: 역할, 책임, 협력.</p><p>카페테리아에 방문하여 커피를 주문하는 일련의 과정을 예로 들자면…</p><p>요청과 응답을 통해 다른 사람과 협력 ⇒ 커피 주문(협력).</p><p>협력하는 과정 속에서 특정한 역할을 부여 받는다 ⇒ 손님, 캐시어, 바리스타(역할).</p><p>특정한 역할은 특정한 책임을 암시한다. 협력에 참여하며 특정한 역할을 수행하는 사람들은 역할에 적합한 책임을 수행하게 된다 ⇒ 손님, 캐시어, 바리스타 각자가 수행해야 할 책임들(책임).</p><h2 id="협력"><a href="#협력" class="headerlink" title="협력"></a>협력</h2><p>협력의 핵심 ⇒ 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성.</p><blockquote><p>“어떤 객체도 섬이 아니다” by 워드 커닝험, 켄트 벡.</p></blockquote><p>사용자가 최종적으로 인식하게 되는 시스템의 기능은 객체들이 성실히 협력해서 일궈낸 결실이다.</p><h2 id="책임"><a href="#책임" class="headerlink" title="책임"></a>책임</h2><p>애플리케이션의 기능은 좀 더 작은 책임으로 분할되고 책임은 적절한 역할을 수행할 수 있는 객체에 의해 수행된다.</p><p>객체지향 설계 ⇒ <strong><em>적절한 객체에게 적절한 책임을 할당하는 것</em></strong>에서 시작.</p><h2 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h2><p>역할은 <strong><em>관련성 높은 책임의 집합</em></strong>.</p><p>객체 역할의 특징</p><ul><li>여러 객체가 동일 역할을 수행할 수 있다.</li><li>역할은 대체 가능성을 의미한다.</li><li>각 객체는 책임 수행 방법을 자율적으로 선택할 수 있다.</li><li>하나의 객체가 동시에 여러 역할을 수행할 수 있다.</li></ul><h2 id="협력-공동체-일원으로서-객체가-갖춰야-하는-2가지-덕목"><a href="#협력-공동체-일원으로서-객체가-갖춰야-하는-2가지-덕목" class="headerlink" title="협력 공동체 일원으로서 객체가 갖춰야 하는 2가지 덕목"></a>협력 공동체 일원으로서 객체가 갖춰야 하는 2가지 덕목</h2><ul><li>객체는 충분히 협력적이어야 한다. 외부의 도움을 무시한 채 모든 것을 스스로 처리하려는 전지전능한 객체(god object)는 내부적인 복잡도에 의해 자멸하고 만다. 여기서 충분히 협력적이라는 말이 다른 객체의 명령에 따라 행동하는 수동적인 존재를 의미하는 것은 아니라는 사실에 주의할 것. 객체는 다른 객체의 명령에 복종하는 것이 아니라 요청에 응답할 뿐이다.</li><li>객체는 충분히 자율적이어야 한다. 객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만 스스로의 결정과 판단에 따라 행동하는 자율적인 존재.</li></ul><h2 id="객체의-자율성"><a href="#객체의-자율성" class="headerlink" title="객체의 자율성"></a>객체의 자율성</h2><p>객체가 자율적인 존재로 남기 위해서는 필요한 행동과 상태를 함께 지니고 있어야 한다.</p><p>객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 나온다.</p><h2 id="협력과-메시지"><a href="#협력과-메시지" class="headerlink" title="협력과 메시지"></a>협력과 메시지</h2><p>객체지향의 세계에서는 오직 한 가지 의사소통 수단만이 존재하는데 이것이 <strong>메시지</strong>.</p><p>객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른 객체로부터 메시지를 수신한다.</p><p>A 객체가 B 객체에게 무언가를 요청하는 것 ⇒ A 객체 입장에서는 메시지 전송, B 객체 입장에서는 메시지 수신.</p><h2 id="메서드와-자율성"><a href="#메서드와-자율성" class="headerlink" title="메서드와 자율성"></a>메서드와 자율성</h2><p><strong>메서드</strong> : 객체가 수신된 메시지를 처리하는 방법.</p><p>외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 <strong><em>객체의 자율성을 높이는 핵심 메커니즘인데 이는 캡슐화와도 깊이 관련되어 있다</em></strong> ⇒ 메시지와 메서드를 분리하는 것은 객체의 자율성을 증진시킨다.</p><h2 id="객체지향의-본질"><a href="#객체지향의-본질" class="headerlink" title="객체지향의 본질"></a>객체지향의 본질</h2><ul><li>객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법.</li><li>자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미.</li><li>객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합.</li><li>객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.</li></ul><h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><p>클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소인 것은 분명하지만 객체지향의 핵심을 이루는 중심 개념이라고 말하기에는 무리가 있다.</p><p>중요한 것은 “어떤 클래스가 필요한가”가 아니라 “어떤 객체들이 어떤 메시지를 주고받으며 협력하는가”다. <strong><em>클래스는 객체들의 협력 관계를 코드로 옮기는 도구</em></strong>에 불과하다.</p><p>클래스가 중요하지 않다는 것이 아니라 단지 협력 구조와 책임을 식별하는 것에 비해 상대적으로 덜 중요하다는 것.</p><p>클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/objected-oriented-facts-and-misunderstandings.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;아래 내용은 조영호님의 “객체지향의 사실과 오해” 1장(협력하는 객체들의 공동체)을 읽고 개인적으로 
      
    
    </summary>
    
    
      <category term="OOP" scheme="https://jheloper.github.io/tags/OOP/"/>
    
      <category term="객체지향" scheme="https://jheloper.github.io/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"/>
    
      <category term="Book" scheme="https://jheloper.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>(많이 늦은) 2019년 하반기 회고</title>
    <link href="https://jheloper.github.io/2020/02/retrospective-2019-second-half/"/>
    <id>https://jheloper.github.io/2020/02/retrospective-2019-second-half/</id>
    <published>2020-02-09T14:50:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/clock.jpg" alt></p><h2 id="오랜만에-적는-글이자-하반기-회고"><a href="#오랜만에-적는-글이자-하반기-회고" class="headerlink" title="오랜만에 적는 글이자 하반기 회고"></a>오랜만에 적는 글이자 하반기 회고</h2><p>무척 오랜만에 적는 회고인 듯 하다. 원래는 분기마다 회고를 하고자 했는데 나의 게으름으로 인해 3분기, 4분기는 합쳐서 하반기 회고로 한꺼번에 하게 되었다. 여러모로 반성하게 되는 순간이지만 그래도 일단 2019년 하반기 회고를 시작해보자.</p><h2 id="2019년의-하반기를-돌아보며"><a href="#2019년의-하반기를-돌아보며" class="headerlink" title="2019년의 하반기를 돌아보며"></a>2019년의 하반기를 돌아보며</h2><h3 id="퇴사-그리고-이직"><a href="#퇴사-그리고-이직" class="headerlink" title="퇴사, 그리고 이직"></a>퇴사, 그리고 이직</h3><p>2019년 7월이 끝나갈 때 즈음에 다니던 회사를 그만두었다. 1년이 조금 넘게 다녔던 회사를 또 그만둔 이유는 여러가지가 있었는데 가장 큰 이유로는 번아웃이 회복되지 않았으며, 회사의 개발 조직이 점차 성장하고 있는지와 구성원들에게 충분한 보상을 주고 있는지에 대한 회의감이 들었기 때문이었다. 물론 회사에서 많은 역할을 맡고 많은 일들을 하면서 배운 것도 많았지만 그것만으로는 뭔가 부족하다는 생각이 들었다.</p><p>그리하여 2019년 8월, 새로운 회사에서의 새로운 생활이 시작되었다. 새로운 회사에서 일하기 시작한지 어언 6, 7개월 차가 되었는데 만족도는 비교적 높은 편이다. 전에 다녔던 회사들에 비교하자면 직원에 대한 복지도 상당히 신경쓰고 있다 느껴지고, 열정적이고 프로페셔널한 사람들이 많이들 모여있어서 나도 모르게 동기 부여도 되고 있으며, 회사가 성장하는 모습이 가시적으로 보이는 것도 마음에 든다.</p><h3 id="새로운-서비스와의-만남"><a href="#새로운-서비스와의-만남" class="headerlink" title="새로운 서비스와의 만남"></a>새로운 서비스와의 만남</h3><p>따라서 하반기에는 새로운 회사에서 담당하게 된 새로운 서비스에 적응하는 것에 집중했다.</p><p><strong>여러 공급사들의 API를 연동하는 서비스</strong>인데, 연동하고 있는 공급사만 무려 십여 개가 넘었고 당연하게도 각 공급사의 API 규격도 제각각인 상황이었다. 이런 공급사들을 아우르는 서비스였기에 생각만큼 복잡한 서비스였지만 그래도 이전 회사에서도 접했던 부분이었기 때문에 비교적 금방 적응할 수 있었다.</p><p>아직 짧은 기간이지만 새로운 공급사 연동 개발 및 기존의 이슈 몇 가지를 처리하면서 충분히 적응하게 된 것 같아서 다행이라고 생각하고 있다.</p><h3 id="메시지-큐-Message-Queue-를-이용한-비동기-처리를-경험하다"><a href="#메시지-큐-Message-Queue-를-이용한-비동기-처리를-경험하다" class="headerlink" title="메시지 큐(Message Queue)를 이용한 비동기 처리를 경험하다"></a>메시지 큐(Message Queue)를 이용한 비동기 처리를 경험하다</h3><p>새롭게 담당한 서비스에서 <strong><em>메시지 큐를 이용한 비동기 처리</em></strong>를 도입하고 있었는데, 이렇게 서비스에서 메시지 큐를 사용할 수 있다는 걸 지식으로는 알고 있었지만 실제 사례는 처음 접해봤다.</p><p>원래 이전 회사에 있을 때 도입하려고 했었으며 꽤 관심을 가졌던 부분이기도 해서 나에게는 때마침 찾아온 좋은 경험이었다.</p><p>일단 내가 담당한 서비스에서 사용하고 있는 것은 <strong>RabbitMQ</strong>이었기에 이를 연동하여 사용하는 방법을 경험할 수 있었는데 공부하다보니 메시징 시스템의 기본적인 컨셉은 알 수 있었다.</p><p>또한 앞으로 회사 내 여러 시스템들에서 통합해서 사용할 예정인 분산 스트리밍 플랫폼, <strong><em>아파치 카프카(Apache Kafka)를 통한 메시지 커뮤니케이션</em></strong>을 접할 수 있을거라는 기대를 하고 있다.</p><h3 id="도메인-주도-설계-DDD-Domain-Driven-Design-공부를-시작하다"><a href="#도메인-주도-설계-DDD-Domain-Driven-Design-공부를-시작하다" class="headerlink" title="도메인 주도 설계(DDD, Domain Driven Design) 공부를 시작하다"></a>도메인 주도 설계(DDD, Domain Driven Design) 공부를 시작하다</h3><p>새로운 회사의 개발 조직에서는 <strong><em>도메인 주도 설계를 적극적으로 도입</em></strong>하고 있는 분위기였다. 나도 관심은 있었지만 아직 시작도 못하고 있었는데 “마침 잘 됐다!” 싶은 마음에 도메인 주도 설계 공부를 시작했다. </p><p>에릭 에반스의 “도메인 주도 설계” 책이 유명하지만 처음 시작으로는 쉽지 않다고 하여 다른 책을 읽었는데, 아직은 지식으로만 접한 정도이고 실무와 접목할 때에는 실제로 어떻게 해야하는지는 잘 모르기 때문에 좀 더 공부를 하면서 블로그에도 정리를 해둬야겠다는 생각이 들었다.</p><h3 id="한-달에-한-권-독서"><a href="#한-달에-한-권-독서" class="headerlink" title="한 달에 한 권 독서"></a>한 달에 한 권 독서</h3><p>한 달에 한 권은 역시 쉽지 않았다. 하반기에 전부 읽은 책은 “도메인 주도 설계란 무엇인가?(Domain Driven Design Quickly)”, “다이내믹 프로그래밍 완전 정복”, “객체지향의 사실과 오해” 총 3권이었다. 그 외에 읽고 있는 책으로는 여러 책들이 있는데 존 도어의 “OKR”이나 “DDD Start!”, “신경 끄기의 기술” 등이 있다.</p><p>내가 워낙 책을 읽을 때 한 권만 계속 붙잡고 읽는 성격이 아니다보니 읽고 있는 책은 여러 권이 있지만 다 읽은 책은 비교적 적은 편이다.</p><h3 id="혼자만의-생활을-시작하다"><a href="#혼자만의-생활을-시작하다" class="headerlink" title="혼자만의 생활을 시작하다"></a>혼자만의 생활을 시작하다</h3><p>그리고 또 한 가지의 큰 변화라면 9월 말, 결국 자취를 시작하게 되었다. 그 동안 본가에서 부모님과 함께 생활했지만 한 번쯤은 혼자만의 생활을 해보길 원했기 때문에 자취 시작을 속전속결로 결정해버렸다. 더군다나 이직 후 본가에서 회사로의 출퇴근 길이 더더욱 멀어졌다는 사실이 결정을 내리는 데에 한몫했다.</p><p>그렇게 자취를 시작한지 5개월 정도 된 상태인데 물론 귀찮고 불편한 점이 없는 건 아니지만 아직은 새로운 공간에서의 나홀로 생활에 충분히 만족하고 있다.</p><h3 id="개인-공부"><a href="#개인-공부" class="headerlink" title="개인 공부"></a>개인 공부</h3><p>러스트(Rust)는 계속 공부하고 있다. “Rust Language Book”의 절반 정도 진도를 나갔는데, 남은 진도를 얼른 끝내고 멀티스레드 웹 서버 예제를 만들고 싶다.</p><p>리액트(React)는 아무래도 프론트엔드 개발을 할 때 워낙 많이 쓰이다보니 시작했다. 개인 프로젝트에서도 웹 프론트엔드 개발을 해야할 때가 있어서 시작하게 됐는데 상태 관리와 컴포넌트의 라이프 사이클에 대한 내용을 공부해보니 어떤 느낌인지는 알 것 같지만 자바스크립트 기본이 부족해서 아직 막히는 부분이 많다.</p><p>플러터(Flutter)는 모바일 앱을 만들어보고 싶은 마음에 개발 환경을 세팅하고 Getting started 정도를 따라해봤는데 확실히 하나의 코드로 안드로이드, iOS 앱이 만들어진다는 사실이 매우 매력적이었다. 하지만 내가 앱 개발에 대해서 아직 아는 부분이 별로 없다는 사실도 여실히 느꼈다.</p><p>코틀린(Kotlin)은 회사에서도 도입해보려고 시도하는 중이기에 조금씩 공부하고 있다. 개인적으로는 아직 자바도 공부할 것이 많은데 코틀린을 공부하는게 맞나 싶지만 요즘 트렌드가 되어가고 있는 이유가 뭔가 있을거란 생각과 회사에서 사용해야할 때를 대비하고자 공부하고 있다.</p><h3 id="블로그-관리"><a href="#블로그-관리" class="headerlink" title="블로그 관리"></a>블로그 관리</h3><p>2019년의 목표였던 <strong>1달 2포스팅</strong>은 9월 즈음부터 지키지 못했다. 핑계를 대자면 위에서 얘기했던 퇴사와 이직, 자취 시작 등과 같은 개인적인 이유들을 댈 수 있겠으나 결국은 내 게으름이 가장 큰 이유일 것이다. 새삼 꾸준히 블로그 포스팅을 하는 블로거 분들이 대단하다고 느꼈다.</p><h3 id="하반기-결산"><a href="#하반기-결산" class="headerlink" title="하반기 결산"></a>하반기 결산</h3><p>퇴사와 이직, 자취 시작과 같은 개인적인 대소사들이 많았으나 어쨌든 목표했던 바를 이루지 못했던 것은 아쉽다. 블로그 관리는 절반 정도, 한 달에 한 권 독서도 절반 정도 밖에 달성하지 못했으니 전체적으로 보자면 많아야 목표의 절반 정도 달성한 것일까. 개인 공부는 꽤나 여러 가지를 진행 중인데 아직 초기 단계라서 실제로 동작하는 뭔가를 만들지는 못한 것이 아쉽다. 그래도 메시징 시스템이나 도메인 주도 설계와 같은 새로운 것들을 경험하게 된 것은 꽤 의미있었다.</p><h2 id="2020년-새해를-맞이하며"><a href="#2020년-새해를-맞이하며" class="headerlink" title="2020년, 새해를 맞이하며"></a>2020년, 새해를 맞이하며</h2><h3 id="무엇을-이룰-것인가"><a href="#무엇을-이룰-것인가" class="headerlink" title="무엇을 이룰 것인가"></a>무엇을 이룰 것인가</h3><p>개인 공부 중 러스트, 리액트는 우선적으로 계속 공부할 예정이다. 리액트는 사실 자바스크립트 기본이 부족한 상태라서 자바스크립트 기본을 먼저 공부할 것이다.</p><p>또한 도메인 주도 설계와 객체지향 프로그래밍, 함수형 프로그래밍과 반응형 프로그래밍에 대해서도 좀 더 공부가 필요하다. 특정 스킬을 익히는 것만큼 컨셉과 패러다임을 공부하는 것이 중요하다고 요즘 더욱 절실히 느끼고 있다.</p><h3 id="무엇을-포기할-것인가"><a href="#무엇을-포기할-것인가" class="headerlink" title="무엇을 포기할 것인가"></a>무엇을 포기할 것인가</h3><p>“분기 회고”는 이제 “반기 회고”로 바꿀 생각이다.</p><p>“한 달에 한 권 독서”도 일단 “2달에 한 권”으로, 블로그 포스팅은 “1달 2포스팅”은 “1달 1포스팅”으로 재조정 해야겠다.</p><p>개인 공부도 일단 우선 순위에 따라 먼저할 것을 정했기에 나머지는 보류할지도 모르겠다.</p><p>요즘 “신경 끄기의 기술”이라는 책을 읽으면서 느낀 것인데, 사실 나는 욕심을 많이 부려서 해야할 일만 늘리고 무엇을 포기할 것인가에 대해서는 생각하지 않았던 것 같다. 그래서 2020년에는 무엇을 포기할 것인가, 에 대해서도 깊게 생각해보는 시간을 가져야겠다.</p><p>부디 중요한 가치를 가진 것에 집중해서 신경 쓸 수 있는 2020년이 되기를 염원하며, 2019년 하반기의 회고를 마무리하자.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/clock.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;오랜만에-적는-글이자-하반기-회고&quot;&gt;&lt;a href=&quot;#오랜만에-적는-글이자-하반기-회고&quot; class=&quot;headerlink&quot; title=&quot;오랜만에 적는 글이자 하반기
      
    
    </summary>
    
    
      <category term="Retrospective" scheme="https://jheloper.github.io/tags/Retrospective/"/>
    
  </entry>
  
  <entry>
    <title>JPA(Java Persistence API) 05 - 연관관계(사용법)</title>
    <link href="https://jheloper.github.io/2020/01/jpa-05-relation-usage/"/>
    <id>https://jheloper.github.io/2020/01/jpa-05-relation-usage/</id>
    <published>2020-01-27T14:50:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jpa-logo.png" alt></p><h2 id="연관관계-저장"><a href="#연관관계-저장" class="headerlink" title="연관관계 저장"></a>연관관계 저장</h2><p>JPA에서 엔티티를 저장할 때 연관된 <code>모든 엔티티는 영속 상태</code>여야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Team team1 = <span class="keyword">new</span> Team();</span><br><span class="line">team1.setTeamName(<span class="string">"team1"</span>);</span><br><span class="line">team1.setTeamType(TeamType.A);</span><br><span class="line">entityManager.persist(team1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Member member1 = <span class="keyword">new</span> Member();</span><br><span class="line">member1.setUsername(<span class="string">"member1"</span>);</span><br><span class="line">member1.setAge(<span class="number">20</span>);</span><br><span class="line">member1.setTeam(team1); <span class="comment">// Member와 Team 간 연관관계 저장</span></span><br><span class="line">entityManager.persist(member1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Member member2 = <span class="keyword">new</span> Member();</span><br><span class="line">member2.setUsername(<span class="string">"member2"</span>);</span><br><span class="line">member2.setAge(<span class="number">10</span>);</span><br><span class="line">member2.setTeam(team1); <span class="comment">// Member와 Team 간 연관관계 저장</span></span><br><span class="line">entityManager.persist(member2);</span><br></pre></td></tr></table></figure><h3 id="양방향-연관관계-저장"><a href="#양방향-연관관계-저장" class="headerlink" title="양방향 연관관계 저장"></a>양방향 연관관계 저장</h3><p>양방향 연관관계 저장 시 주의할 점으로는 <code>연관관계의 주인이 아닌 엔티티에서 연관관계를 저장해도 실제로 데이터베이스에 저장되지 않는다</code>는 점이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Member member1 = <span class="keyword">new</span> Member();</span><br><span class="line">member1.setUsername(<span class="string">"member1"</span>);</span><br><span class="line">member1.setAge(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// member1.setTeam(team1);</span></span><br><span class="line">entityManager.persist(member1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Member member2 = <span class="keyword">new</span> Member();</span><br><span class="line">member2.setUsername(<span class="string">"member2"</span>);</span><br><span class="line">member2.setAge(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// member2.setTeam(team1);</span></span><br><span class="line">entityManager.persist(member2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Team team1 = <span class="keyword">new</span> Team();</span><br><span class="line">team1.setTeamName(<span class="string">"team1"</span>);</span><br><span class="line">team1.setTeamType(TeamType.A);</span><br><span class="line"><span class="comment">// 연관관계의 주인이 아닌 쪽에서 아래와 같이 연관관계를 저장해도 데이터베이스에는 저장되지 않는다.</span></span><br><span class="line">team1.setMembers(Lists.newArrayList(member1, member2));</span><br><span class="line">entityManager.persist(team1);</span><br></pre></td></tr></table></figure><p>그렇다고 연관관계의 주인 쪽에만 객체를 저장하지는 말고, 양쪽 방향 모두 객체를 저장해주는 것이 가장 안전하다.</p><p>아래와 같이 연관관계 저장 시 연관관계의 주인이 아닌 쪽에도 관계가 설정되도록 기능을 확장할 수 있다. 아래 예제 코드를 참조할 것.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"member"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTeam</span><span class="params">(Team team)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.team != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 기존에 설정된 연관관계는 아래와 같이 제거해야 한다.</span></span><br><span class="line">            <span class="keyword">this</span>.team.getMembers().remove(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.team = team;</span><br><span class="line">        <span class="comment">// 연관관계의 주인이 아닌 쪽에도 아래와 같이 관계를 설정해주는 편이 안전하다.</span></span><br><span class="line">        team.getMembers().add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="연관관계-조회"><a href="#연관관계-조회" class="headerlink" title="연관관계 조회"></a>연관관계 조회</h2><h3 id="객체-그래프-탐색"><a href="#객체-그래프-탐색" class="headerlink" title="객체 그래프 탐색"></a>객체 그래프 탐색</h3><p>객체 연관관계를 사용한 객체 그래프 탐색으로 연관관계 엔티티를 조회할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Member member = entityManager.find(Member.class, member1.getId());</span><br><span class="line"><span class="keyword">final</span> Team team = member.getTeam();</span><br></pre></td></tr></table></figure><h3 id="JPQL-사용"><a href="#JPQL-사용" class="headerlink" title="JPQL 사용"></a>JPQL 사용</h3><p>객체지향 쿼리인 JPQL의 조인을 사용하여 연관관계 엔티티를 조회할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String jpql = <span class="string">"select m from Member m join m.team t where t.teamName=:teamName"</span>;</span><br><span class="line"><span class="keyword">final</span> List&lt;Member&gt; resultList = entityManager.createQuery(jpql, Member.class)</span><br><span class="line"> .setParameter(<span class="string">"teamName"</span>, team1.getTeamName())</span><br><span class="line"> .getResultList();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> Member member : resultList) &#123;</span><br><span class="line">System.out.println(<span class="string">"member's username="</span> + member.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="연관관계-수정"><a href="#연관관계-수정" class="headerlink" title="연관관계 수정"></a>연관관계 수정</h2><p>엔티티의 연관관계 엔티티만 변경해두면 트랜잭션 커밋 시 변경 감지 기능이 작동하여 연관관계가 수정된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Team team2 = <span class="keyword">new</span> Team();</span><br><span class="line">team2.setTeamName(<span class="string">"team2"</span>);</span><br><span class="line">team2.setTeamType(TeamType.B);</span><br><span class="line">entityManager.persist(team2);</span><br><span class="line"></span><br><span class="line">findMember1.setTeam(team2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Member findMember2 = entityManager.find(Member.class, member.getId());</span><br><span class="line">System.out.println(findMember2.getTeam().getTeamName());</span><br></pre></td></tr></table></figure><h2 id="연관관계-제거"><a href="#연관관계-제거" class="headerlink" title="연관관계 제거"></a>연관관계 제거</h2><p>연관관계를 <code>null</code>로 설정하면 연관관계가 제거된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Member findMember = entityManager.find(Member.class, member.getId());</span><br><span class="line">findMember.setTeam(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>연관된 엔티티를 삭제할 때에는 <code>기존의 연관관계 먼저 제거하고 삭제</code>할 것. 아래 코드는 외래 키 제약조건으로 인해 오류가 발생한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">member1.setTeam(team1);</span><br><span class="line">member2.setTeam(team2);</span><br><span class="line"></span><br><span class="line">member1.setTeam(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// member2.setTeam(null);</span></span><br><span class="line"></span><br><span class="line">entityManager.remove(team1);</span><br></pre></td></tr></table></figure><blockquote><p>위 내용은 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>를 읽으며 개인적으로 요약 및 정리하는 내용이다.<br>자세한 내용이 알고 싶으면 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>을 직접 읽어보길 추천한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jpa-logo.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;연관관계-저장&quot;&gt;&lt;a href=&quot;#연관관계-저장&quot; class=&quot;headerlink&quot; title=&quot;연관관계 저장&quot;&gt;&lt;/a&gt;연관관계 저장&lt;/h2&gt;&lt;p&gt;JPA에서 
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://jheloper.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://jheloper.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>다이내믹 프로그래밍 완전 정복 리뷰</title>
    <link href="https://jheloper.github.io/2019/12/book-review-dynamic-programming-for-coding-interviews/"/>
    <id>https://jheloper.github.io/2019/12/book-review-dynamic-programming-for-coding-interviews/</id>
    <published>2019-12-15T12:00:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/book-cover-2019-12-15.jpg" alt></p><p>나는 다이내믹 프로그래밍이 정확히 무엇을 의미하는지 전혀 알지 못하는 상태였기 때문에 약간의 부담감을 안고 책을 읽기 시작했는데, 그런 나에게 이 책은 다이내믹 프로그래밍이 무엇인지에 대해서 맛볼 수 있는 중요한 기회를 선사해주었다.</p><p>일단 책의 처음은 <strong>재귀</strong>에 대한 내용으로 시작한다. 재귀의 경우 꽤나 자주 접했기에 비교적 쉽게 이해할 수 있었다. 책의 내용 중에서 <strong><em>재귀를 사용할 때 주의해야할 것</em></strong>에 대해서 아래와 같이 나와있었다.</p><ol><li>재귀에는 항상 종료 조건이 있어야 한다. 종료 조건이 없으면 재귀 호출이 무한히 반복된다.</li><li>재귀 함수는 전체 작업의 일부만 수행하고 나머지는 재귀 호출에 위임한다.</li></ol><p>어찌보면 너무나 당연한 이야기였지만, 너무나 당연하기 때문에 간과할 수 있는 부분에 대해서 명확하게 짚어주고 있었다.</p><p>또한 재귀에 대해 설명하면서 아래와 같은 말도 덧붙이고 있었다.</p><blockquote><p>쉬운 코드와 복잡한 코드 중에 선택해야 한다면, 성능이나 메모리의 이점이 있지 않은 한 쉬운 코드가 좋습니다.</p></blockquote><blockquote><p>같은 문제를 비슷한 노력으로 해결할 수 있다면 재귀 호출을 사용하지 않는 쪽으로 구현하는 것이 바람직합니다. 만들어진 프로그램을 실행하보면 재귀 호출을 사용하지 않는 경우가 실행도 빠르고 필요한 메모리의 양도 작습니다.</p></blockquote><p>깊이 공감한다. 정말 명확한 이유가 있지 않은 한 재귀 호출을 남발하는 것은 좋지 않다고 생각한다. 물론 재귀 호출로 문제를 푸는 것이 우아하고 세련된 방법처럼 보일 수 있지만, 재귀 호출은 이를 사용하지 않는 경우에 비해 일반적으로 더 많은 비용이 들기 때문이다.</p><p>이어서 <strong>선행 재귀</strong>와 <strong>후행 재귀</strong>에 대해서도 설명해주고 있는데, 연결 리스트의 탐색 예제를 통해 설명해주는 부분이 나름 직관적으로 와닿았다. </p><p>그리고 재귀 호출과 메모리에 대한 내용이 있었는데, 특히 <strong>프로세스 주소 공간</strong>에 대한 설명은 꽤나 유용했다. <strong>코드 영역, 데이터 영역, 스택 영역, 힙 영역</strong> 각각에 대해 간략하지만 핵심적인 설명이 있었으며 특히나 <strong><em>프로그램의 로딩부터 함수의 호출로 인한 메모리의 변화가 어떻게 일어나는지</em></strong>에 대해 설명하는 부분이 유용하다고 느껴졌다.</p><p>재귀를 사용할 때와 사용하지 않을 때 메모리의 상태 비교를 통해 책에서는 아래와 같이 이야기한다.</p><blockquote><p>재귀 호출을 사용하면 메모리와 실행 시간 양 측면에서 비용이 증가합니다.</p></blockquote><p>이에 이어 다음으로는 재귀 접근 방식이 가지는 두 가지 특징에 대해서 언급하는데 그 첫번째는 <strong>최적의 하위 구조</strong>로, 아래와 같이 설명하고 있다.</p><blockquote><p>어떤 문제의 풀이법을 같은 문제의 더 작은 문제로 정의하는 게 최적의 풀이법이라면 이 문제는 최적의 하위 구조를 가졌다고 합니다. 최적의 하위 구조를 가진 문제는 다이내믹 프로그래밍 방법을 적용하기 좋은 문제입니다.</p></blockquote><p>그리고 두번째 특징으로는 <strong>하위 문제의 반복 계산</strong>에 대해서 언급하는데, 책의 본문에서는 피보나치 수열 계산 문제에서의 하위 문제의 반복 계산을 예로 들고 있다. 그리고 이어서 <strong><em>하위 문제의 반복 계산이 발생하여 수행 시간이 증가하는 문제를 해결하기 위한 방법</em></strong>으로 <strong>메모 전략(메모이제이션)</strong>을 소개하는데, 이를 쉽게 말하면 <strong><em>어떤 하위 문제를 계산했을 때 그 결과를 일종의 캐시에 저장하여 같은 하위 문제를 다시 풀 때 이미 저장된 결과를 사용</em></strong>하는 방식을 의미한다. 또한 메모 전략에 대해서 아래와 같이 언급하고 있다.</p><blockquote><p>메모 전략도 재귀 접근 방법에 속합니다.</p></blockquote><blockquote><p>메모 전략 = 재귀 호출 + 캐시 - 하위 문제의 반복 계산.</p></blockquote><p>이어서 드디어 주인공인 <strong>다이내믹 프로그래밍</strong>에 대한 내용이 본격적으로 등장하는데, 가장 처음 알게된 것은 문제 해결의 방향이 <strong><em>재귀 호출, 또는 메모 전략은 하향식인 반면 다이내믹 프로그래밍은 상향식</em></strong>이라는 사실이었다.</p><p>앞에서 재귀 호출 또는 메모 전략을 통해 풀었던 예제들을 보여주면서 이를 다이내믹 프로그래밍으로 해결할 수 있음을 보여주는데, 이와 함께 직접 깃헙에 재귀 호출, 메모 전략, 다이내믹 프로그래밍의 실행 시간을 비교해볼 수 있는 예제 코드를 올려놨다는 점이 좋았다.</p><p>동일한 문제를 각각 하향식 접근 방법과 상향식 접근 방법로 풀어내는 예제 코드들로 하여금 그 둘이 어떤 차이점을 가지는지를 비교해볼 수 있었다.</p><p>그리고 결론적으로 <strong><em>다이내믹 프로그래밍은 재귀 호출 자체로부터 발생하는 부하를 피하기 위해 상향식으로 문제를 해결할 수 있다</em></strong>, 라는 내용을 전달하고 있었다.</p><p>더 나아가 그렇다고 다이내믹 프로그래밍이 은탄환은 아니라는 것에 대해서 설명해주는데, 하향식 접근 방법에서는 모든 하위 문제를 풀지 않고 전체 문제의 해답을 얻을 때 필요한 하위 문제만 풀었으나 상향식인 <strong><em>다이내믹 프로그래밍에서는 모든 하위 문제에 대해 계산을 수행하여 드물게 실제 필요한 것보다 훨씬 더 많은 하위 문제를 풀어야 하는 부작용이 발생</em></strong>하기도 한다는 점에 대해서 설명해주고 있다.</p><p>이에 이어 다이내믹 프로그래밍이 어떤 것이다, 라는 설명에서 그치지 않고 실제로 어떻게 적용할 수 있는지를 알려주는데, <strong>다이내믹 프로그래밍을 사용해서 문제를 푸는 기본적인 순서</strong>는 아래와 같이 알려주고 있다.</p><ol><li>재귀 호출을 사용한 풀이법 작성.</li><li>다이내믹 프로그래밍이나 메모 전략을 사용해 풀이법 개선.</li></ol><p>그리고 어떤 문제가 <strong>다이내믹 프로그래밍 적용 가능 여부를 확인할 수 있는 체크리스트</strong>도 아래와 같이 알려주고 있다.</p><ol><li>문제가 최적의 하위 구조를 가지고 있는지.</li><li>하위 문제를 반복 계산하는지.</li><li>최적화, 최대화 또는 최소화나 어떤 작업의 경우의 수를 구하는 유형의 문제인지.</li></ol><p>더불어 <strong>다이내믹 프로그래밍을 적용하기 위한 단계식 접근법</strong>도 친절하게 알려주고 있다.</p><ol><li>다이내믹 프로그래밍 적용 가능한 경우인지 확인.</li><li>점화식 또는 재귀 과정 정의.<ol><li>문제를 하위 문제를 사용해 하향식으로 정의.</li><li>맨 아래에 해당하는 기본 경우에 대한 답을 정의.</li><li>종료 조건 추가.</li></ol></li><li>(선택적) 메모 전략 시도.</li><li>상향식으로 문제 풀이 도전.</li></ol><p>위와 같이 실제로 적용할 수 있는 방법에 대해서도 설명해주고 있는 점이 상당히 유용하다고 느껴졌는데, 다이내믹 프로그래밍이 무엇인지 알았다고 해서 어디에 어떻게 사용해야 하는지 단번에 알 수 있는 건 아니라고 느꼈기 때문이다. 그리고 이러한 단계식 접근법을 여러 예제 문제들에 적용하는 과정을 보여주고 있다는 점에서 상당히 마음에 들었다.</p><p>이 책의 전체적인 소감은 이론적인 부분의 설명은 적당하게, 최대한 부담되지 않는 선에서 하면서 실제로 적용해볼 수 있는 여러 문제를 소개해주고 풀어내는 과정을 통해 재귀 호출과 메모 전략, 다이내믹 프로그래밍에 대해서 알려주는 실용적인 책, 이라는 것이었다. 본문 자체에도 꽤나 많은 예제들이 수록되어 있으며, 마지막 장인 5장은 아예 통째로 다양한 실전 문제들을 수록하여 위에서 안내해주는 단계식 접근법을 통해 풀어내는 과정을 보여주면서 연습문제를 통해 독자들 스스로도 한껏 두뇌를 사용할 수 있는 기회를 제공해주고 있다.</p><p>재귀 호출과 메모 전략, 다이내믹 프로그래밍에 대해서 관심이 있으나 아직 입문하지 못한 분들에게 추천하기 좋은 책이라는 생각이 든다.</p><blockquote><p>위 글은 출판사 한빛미디어의 “나는 리뷰어다” 11월 미션 서적으로 제공받은 “다이내믹 프로그래밍 완전 정복(미나크시, 카말 라와트 지음, 박상은 옮김)”의 리뷰입니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/book-cover-2019-12-15.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;나는 다이내믹 프로그래밍이 정확히 무엇을 의미하는지 전혀 알지 못하는 상태였기 때문에 약간의 부담감을 안고 책을 읽기 시작했는데, 그런 나에게 
      
    
    </summary>
    
    
      <category term="다이내믹 프로그래밍" scheme="https://jheloper.github.io/tags/%EB%8B%A4%EC%9D%B4%EB%82%B4%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"/>
    
      <category term="리뷰" scheme="https://jheloper.github.io/tags/%EB%A6%AC%EB%B7%B0/"/>
    
  </entry>
  
  <entry>
    <title>JPA(Java Persistence API) 04 - 연관관계(기본)</title>
    <link href="https://jheloper.github.io/2019/09/jpa-04-relation-basic/"/>
    <id>https://jheloper.github.io/2019/09/jpa-04-relation-basic/</id>
    <published>2019-09-15T13:00:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jpa-logo.png" alt></p><h2 id="연관관계-매핑의-핵심-키워드"><a href="#연관관계-매핑의-핵심-키워드" class="headerlink" title="연관관계 매핑의 핵심 키워드"></a>연관관계 매핑의 핵심 키워드</h2><ul><li>방향성(Direction) : 단방향, 양방향.</li><li>다중성(Multiplicity) : 다대일, 일대다, 일대일, 다대다.</li><li>연관관계의 주인(Owner) : 양방향 연관관계인 경우 연관관계의 주인을 지정해야 한다.</li></ul><h2 id="객체-연관관계와-테이블-연관관계"><a href="#객체-연관관계와-테이블-연관관계" class="headerlink" title="객체 연관관계와 테이블 연관관계"></a>객체 연관관계와 테이블 연관관계</h2><p>연관관계는 <strong>테이블 연관관계</strong>와 <strong>객체 연관관계</strong>로 분류할 수 있다. <strong><em>테이블은 외래키로 연관관계를 맺으며 객체는 참조로 연관관계를 맺는다</em></strong>.</p><p>참조를 통한 객체 연관관계는 언제나 단방향 관계, 외래키를 통한 테이블 연관관계는 양방항 관계이다. 객체 연관관계 중 양방향 관계는 정확히 이야기하면 <em>서로 다른 단방향 관계 2개</em>라고 할 수 있다. 반면 테이블은 외래키 하나로 양방향 관계가 가능하다.</p><h2 id="연관관계의-주인-외래키-관리자"><a href="#연관관계의-주인-외래키-관리자" class="headerlink" title="연관관계의 주인(외래키 관리자)"></a>연관관계의 주인(외래키 관리자)</h2><p>엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래키는 하나이므로 차이가 발생하는데 JPA에서는 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야 한다. 이것을 <strong>연관관계의 주인(Owner)</strong>이라고 한다.</p><p>연관관계의 주인만이 데이터베이스 연관관계에 매핑되고 외래키를 관리(등록, 수정, 삭제)할 수 있다. 반면 주인이 아닌 쪽은 읽기만 할 수 있다.</p><p>주의할 점은, 연관관계의 주인은 <strong>비즈니스 중요도가 아닌 외래키의 위치와 관련해서 결정</strong>한다는 것이다. 연관관계의 주인을 정한다는 것은 사실 <strong>외래키 관리자를 선택하는 것</strong>이며, 따라서 외래 키가 존재하는 테이블로 정해야 한다.</p><p>연관관계의 주인은 mappedBy 속성을 사용하지 않고, 주인이 아닌 쪽은 mappedBy 속성을 사용해서 연관관계의 주인을 지정해야 한다. <em>mappedBy 속성에 지정되는 값은 연관관계의 주인인 엔티티의 참조 필드명</em>이다.</p><h2 id="다대일-연관관계"><a href="#다대일-연관관계" class="headerlink" title="다대일 연관관계"></a>다대일 연관관계</h2><h3 id="단방향"><a href="#단방향" class="headerlink" title="단방향"></a>단방향</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"member"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"team_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Team team;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"team"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ManyToOne"><a href="#ManyToOne" class="headerlink" title="@ManyToOne"></a>@ManyToOne</h3><p>다대일 관계를 매핑할 때 사용한다.</p><ul><li><code>optional</code> : 기본값 true. false로 설정하면 연관된 엔티티가 반드시 있어야 한다.</li><li><code>fetch</code> : 페치 전략을 설정한다.</li><li><code>cascade</code> : 영속성 전이 기능을 설정한다.</li><li><code>targetEntity</code> : 연관된 엔티티 타입 정보를 설정한다.</li></ul><h3 id="JoinColumn"><a href="#JoinColumn" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h3><p>외래키를 매핑할 때 사용한다. 이 어노테이션은 생략할 수 있다.</p><ul><li><code>name</code> : 외래키의 이름을 지정한다. 생략할 경우 외래키를 찾을 때 기본 전략을 사용한다.</li><li><code>referencedColumnName</code> : 외래키가 참조하는 대상 테이블의 컬럼명. 기본값은 참조 테이블의 기본키 컬럼명.</li><li><code>foreignKey</code> : 외래키 제약조건을 DDL로 직접 지정할 수 있다.</li></ul><p><code>@JoinColumn</code>을 생략하면 외래키를 찾을 때 기본 전략이 있다. 기본 전략은 <strong>“필드명_참조테이블컬럼명”</strong>이다.</p><h3 id="양방향"><a href="#양방향" class="headerlink" title="양방향"></a>양방향</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"team"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Team</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany</span>(mappedBy = <span class="string">"team"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Member&gt; members;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다대일 양방향 연관관계는 다대일 단방향 연관관계에서 <code>@ManyToOne</code>을 적용한 반대쪽 엔티티에 <code>@OneToMany</code>를 적용하면 된다.</p><p>이 때 <code>mappedaBy</code> 속성을 통해 연관관계의 주인을 지정한다. 위의 예제에서 연관관계의 주인은 Member 엔티티의 team 필드다.</p><h2 id="일대다-연관관계"><a href="#일대다-연관관계" class="headerlink" title="일대다 연관관계"></a>일대다 연관관계</h2><p>일대다 단방향 관계에서 외래키는 항상 다쪽 테이블에 있기 때문에, 반대편 테이블의 외래키를 관리하는 형태다.</p><h3 id="단방향-1"><a href="#단방향-1" class="headerlink" title="단방향"></a>단방향</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"product_group"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductGroup</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"product_group_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; products;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일대다 단방향 관계를 매핑할 때는 <code>@JoinColumn</code>을 명시해야 한다. 그렇지 않으면 <strong><em>JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블(Join Table) 전략을 기본으로 사용해서 매핑</em></strong>한다.</p><p>일대다 단방향 매핑의 단점은 매핑한 객체가 관리하는 외래키가 다른 테이블에 있다는 것. 해당 테이블에 외래키가 있으면 엔티티의 저장과 연관관계 처리를 INSERT SQL 한 번으로 끝낼 수 있으나 다른 테이블에 외래키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 한다.</p><p>상황에 따라 다르겠지만 <strong>일반적으로 일대다 단방향 매핑보다는 다대일 양방향 매핑을 권장</strong>한다.</p><h3 id="OneToMany"><a href="#OneToMany" class="headerlink" title="@OneToMany"></a>@OneToMany</h3><p>일대다 관계를 매핑할 때 사용한다.</p><ul><li><code>mappedBy</code> : 연관관계의 주인이 아닌 엔티티에서 사용하며 연관관계의 주인을 지정해야 한다.</li><li><code>cascade</code> : 다른 관계 매핑 어노테이션의 cascade 속성과 동일하게 사용.</li><li><code>fetch</code> : 다른 관계 매핑 어노테이션의 fetch 속성과 동일하게 사용.</li><li><code>orphanRemoval</code> : 고아 객체 제거 기능을 설정한다. 기본값 false.</li><li><code>targetEntity</code> : 다른 관계 매핑 어노테이션의 targetEntity 속성과 동일하게 사용.</li></ul><h3 id="양방향-1"><a href="#양방향-1" class="headerlink" title="양방향"></a>양방향</h3><p>일대다 양방향 매핑은 존재하지 않으며 대신 다대일 양방향 매핑을 사용해야 한다. 정확히는 양방향 매핑에서 <code>@OneToMany</code>는 연관관계의 주인이 될 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"product_group_id"</span>, insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> ProductGroup productGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 일대다 양방향 매핑이 완전히 불가능한 것은 아닌데, 위와 같이 반대편 엔티티에 같은 외래키를 사용하는 <strong>다대일 단방향 매핑을 읽기 전용으로 추가하는 방법</strong>이 있다.</p><h2 id="일대일-연관관계"><a href="#일대일-연관관계" class="headerlink" title="일대일 연관관계"></a>일대일 연관관계</h2><p>일대일 관계는 어느 테이블이나 외래키를 가질 수 있다. <strong>일대일 관계는 주 테이블이나 대상 테이블 중 누가 외래키를 가질지 선택</strong>해야 한다. 아래 예제는 주 테이블에 외래 키를 가지는 예제다.</p><h3 id="단방향-2"><a href="#단방향-2" class="headerlink" title="단방향"></a>단방향</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"member"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"member_detail_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> MemberDetail memberDetail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"member_detail"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDetail</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OneToOne"><a href="#OneToOne" class="headerlink" title="@OneToOne"></a>@OneToOne</h3><p>일대일 관계를 매핑할 때 사용한다.</p><ul><li><code>mappedBy</code> : 다른 관계 매핑 어노테이션의 mappedBy 속성과 동일하게 사용.</li><li><code>optional</code> : 다른 관계 매핑 어노테이션의 optional 속성과 동일하게 사용.</li><li><code>cascade</code> : 다른 관계 매핑 어노테이션의 cascade 속성과 동일하게 사용.</li><li><code>fetch</code> : 다른 관계 매핑 어노테이션의 fetch 속성과 동일하게 사용.</li><li><code>orphanRemoval</code> : 다른 관계 매핑 어노테이션의 orphanRemoval 속성과 동일하게 사용.</li><li><code>targetEntity</code> : 다른 관계 매핑 어노테이션의 targetEntity 속성과 동일하게 사용.</li></ul><h3 id="양방향-2"><a href="#양방향-2" class="headerlink" title="양방향"></a>양방향</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"member_detail"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDetail</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@OneToOne</span>(mappedBy = <span class="string">"memberDetail"</span>)</span><br><span class="line">    <span class="keyword">private</span> Member member;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>주 테이블이 외래키를 관리하므로 <code>mappedBy</code> 속성으로 연관관계의 주인을 설정해야 한다. 위의 예제에서 연관관계의 주인은 Member 엔티티의 memberDetail 필드다.</p><h2 id="다대다-연관관계"><a href="#다대다-연관관계" class="headerlink" title="다대다 연관관계"></a>다대다 연관관계</h2><p>다대다 관계의 경우 테이블 연관관계로 표현할 때 중간 관계 테이블을 생성하여 일대다, 다대일 관계로 풀어낸다.</p><h3 id="단방향-3"><a href="#단방향-3" class="headerlink" title="단방향"></a>단방향</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"cart"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cart</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable</span>(name = <span class="string">"cart_product"</span>,</span><br><span class="line">               joinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"product_id"</span>),</span><br><span class="line">               inverseJoinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"cart_id"</span>))</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; products;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="@ManyToMany"></a>@ManyToMany</h3><p>다대다 관계를 매핑할 때 사용한다.</p><ul><li><code>mappedBy</code> : 다른 관계 매핑 어노테이션의 mappedBy 속성과 동일하게 사용.</li><li><code>targetEntity</code> : 다른 관계 매핑 어노테이션의 targetEntity 속성과 동일하게 사용.</li><li><code>cascade</code> : 다른 관계 매핑 어노테이션의 cascade 속성과 동일하게 사용.</li><li><code>fetch</code> : 다른 관계 매핑 어노테이션의 fetch 속성과 동일하게 사용.</li></ul><h3 id="JoinTable"><a href="#JoinTable" class="headerlink" title="@JoinTable"></a>@JoinTable</h3><p>연결 테이블을 지정하는데 사용한다.</p><ul><li><code>name</code> : 연결 테이블명을 지정한다.</li><li><code>joinColumns</code> : 현재 엔티티와 매핑할 조인 컬럼 정보를 지정한다.</li><li><code>inverseJoinColumns</code> : 반대 엔티티와 매핑할 조인 컬럼 정보를 지정한다.</li></ul><h3 id="양방향-3"><a href="#양방향-3" class="headerlink" title="양방향"></a>양방향</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"product"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span>(mappedBy = <span class="string">"products"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Cart&gt; carts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>역방향 엔티티에도 <code>@ManyToMany</code>를 사용하는데, 다대다 관계에서는 연관관계의 주인을 양쪽 중 원하는 곳에 지정하면 된다. 마찬가지로 <code>mappedBy</code> 속성으로 연관관계의 주인을 지정하는데, 위의 경우는 Cart 엔티티의 products 필드를 연관관계의 주인으로 지정한 것이다.</p><h3 id="다대다-관계의-한계"><a href="#다대다-관계의-한계" class="headerlink" title="다대다 관계의 한계"></a>다대다 관계의 한계</h3><p><code>@ManyToMany</code>를 사용하여 연결 테이블을 자동으로 생성하면 여러 가지 편리한 점이 있으나 실무에서 사용하기에는 한계가 있다. <em>보통 연결 테이블에는 양쪽 테이블의 아이디만 담는 것이 아니라 부가적인 컬럼이 필요</em>한데 이 경우에는 <code>@ManyToMany</code>를 사용할 수 없다.</p><p>따라서 이런 경우에는 연결 테이블과 별도로 매핑되는 연결 엔티티를 만들고 양쪽 테이블과의 관계는 일대다, 다대일 관계로 풀어야 한다.</p><blockquote><p>위 내용은 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>를 읽으며 개인적으로 요약 및 정리하는 내용이다.<br>자세한 내용이 알고 싶으면 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>을 직접 읽어보길 추천한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/jpa-logo.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;연관관계-매핑의-핵심-키워드&quot;&gt;&lt;a href=&quot;#연관관계-매핑의-핵심-키워드&quot; class=&quot;headerlink&quot; title=&quot;연관관계 매핑의 핵심 키워드&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://jheloper.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://jheloper.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>2019년 2분기 회고</title>
    <link href="https://jheloper.github.io/2019/07/retrospective-2019-q2/"/>
    <id>https://jheloper.github.io/2019/07/retrospective-2019-q2/</id>
    <published>2019-07-21T13:50:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/clock.jpg" alt></p><p>2019년이 절반이 지난 시점(벌써 20일 넘게 지났지만…), 지난번 1분기 회고에 이어서 2분기 회고를 한 번 해보자.</p><h2 id="회사"><a href="#회사" class="headerlink" title="회사"></a>회사</h2><h3 id="기술부채-해결-및-리팩터링"><a href="#기술부채-해결-및-리팩터링" class="headerlink" title="기술부채 해결 및 리팩터링"></a>기술부채 해결 및 리팩터링</h3><p>2분기는 프로젝트를 바쁘게 진행하면서 지나쳐왔던 기술 부채들을 해결하고자 리팩터링을 진행했다. 이 과정에서 JPA를 좀 더 깊게 이해할 수 있는 기회가 생겼는데, 특히 <code>엔티티 간 관계 설정</code>이 얼마나 중요한지와 <code>OSIV(Open Session In View)</code>가 무엇인지, JPA의 <code>트랜잭션</code>이 어떻게 적용되는지에 대해 알게 되었다.</p><p>또한 부분적으로 구조를 개선하고자 디자인 패턴 중 <code>전략 패턴</code>을 적용했었는데, 이를 시도하면서 전략 패턴이 무엇인지에 대해 좀 더 깊은 이해를 쌓을 수 있어 좋았다.</p><p>기술부채를 해결하고 리팩터링을 하는 과정은 쉬운 것이 아니지만 이를 통해 점차 개선되는 시스템을 보고있자니 시스템이 성장하고 있구나, 라는 감상이 들었다.</p><h3 id="새로운-프로젝트"><a href="#새로운-프로젝트" class="headerlink" title="새로운 프로젝트"></a>새로운 프로젝트</h3><p>사용자들의 유입을 목적으로 기획된 새로운 프로젝트를 맡게 되었고, 도메인 모델링부터 설계 및 개발까지 전부 맡아서 진행했다.</p><p>이 과정에서 다른 서비스를 담당하고 있는 동료들과의 협업, 그리고 특히나 <code>프론트엔드와의 협업</code>을 경험하면서 어떤 부분에 대해서 신경을 써야하는지 경험할 수 있었다.</p><p><strong>프론트엔드와 백엔드 간의 협업에서 정의된 인터페이스를 준수</strong>하는 것이 얼마나 중요하며, 인터페이스에 대한 변경이 있을 경우 프론트엔드에 얼마나 영향을 끼치는지 알 수 있었던 좋은 경험이었다.</p><p>전체적으로 2분기는 무리하지 말고 일하자, 라는 느낌으로 진행하려 했으나 역시나 프로젝트를 맡게 되면 그렇게 진행하기가 쉽지 않은 것 같다. 특히나 개발이 끝나더라도 QA, 버그 픽스, 배포 준비, 배포까지 이뤄지는 과정이 혼자서 일하는 것보다 여럿이서 협업할 때 생각보다 변수가 많아질 수 있다는 것을 뼈저리게 느꼈다.</p><h2 id="개인"><a href="#개인" class="headerlink" title="개인"></a>개인</h2><h3 id="여행"><a href="#여행" class="headerlink" title="여행"></a>여행</h3><p>6월 초, 5박 6일의 일정으로 일본 여행을 다녀왔다. 내 생애 두 번째 해외여행이자 혼자 떠나는 첫 여행이었기 때문에 기대 반 걱정 반을 안고 떠났는데, 상당히 기억에 남는 여행이었다.</p><p>6일 간 히메지, 고베, 교토, 오사카 총 4개의 도시를 여행하면서 좋은 경험들을 많이 했고, 혼자 여행하는 묘미에 대해서도 알게 되었다.</p><p>특히나 돌아다니면서 사진과 영상을 열심히 찍어뒀는데 영상 편집을 간단하게라도 공부해서 여행 브이로그 영상 같은 걸 올려봐야겠다.</p><p>이제 혼자 여행하는 재미도 알게 되었으니, 좀 더 여러 곳으로 여행하면서 다양한 경험을 쌓아볼까나.</p><h3 id="블로그"><a href="#블로그" class="headerlink" title="블로그"></a>블로그</h3><p>1달에 최소 2개 포스팅 목표는 어떻게든 해냈다. 물론 아직도 글을 쓸 때마다 고민이 많고 시간도 오래 걸리지만, 이제 조금은 익숙해졌달까.</p><p>그리고 <strong><a href="https://awesome-devblog.netlify.com/" target="_blank" rel="noopener">Daily DevBlog 서비스</a></strong>를 구독하면서 내 블로그 알림도 신청했는데, 덕분에 많은 사람들에게 내 블로그가 공유되고 있다는 실감이 나면서 한 편으론 약간의 부담감도 생기긴 했다.</p><p>그래도 블로그에 쓰는 글이 다른 사람들에게 도움을 줄 수 있다면 그것만으로도 충분히 의미 있는 일이라 생각이 들며, 앞으로도 꾸준히 블로그를 운영해야겠다고 동기부여가 되는 좋은 계기로 삼았다.</p><h3 id="독서-및-공부"><a href="#독서-및-공부" class="headerlink" title="독서 및 공부"></a>독서 및 공부</h3><p>부끄럽지만 이전에 읽던 책들은 아직도 읽고 있다. 대신 도중에 다른 책에 관심이 생겨서 읽었는데, “소프트 스킬”이라는 책이었다. 이 책에 관심을 가지게 된 것은 여태껏 기술적인 부분에만 신경쓰느라 다른 부분들에 대해서 소홀했던 나에 대한 반성을 시작했기 때문이다.</p><p>또한 어떻게 하면 좀 더 일을 잘할 수 있을까, 라는 고민이 들어 “일 잘하는 사람은 단순하게 합니다”라는 책도 읽었다. 이 책은 전혀 프로그래밍과 관련은 없지만서도, 가끔은 프로그래밍과 관련 없는 책들도 읽으면서 머리를 식혀줄 필요가 있다라고 느꼈기에 간단히 읽어보았다.</p><p>사실 이런 저런 핑계를 대더라도 원래 읽으려던 2권의 책(“토비의 스프링 3.1 1권”, “자바 ORM 표준 JPA 프로그래밍”)은 아직 다 읽지 못했으니 3분기에는 더 분발해서 저 책들을 다 읽도록 해야겠다…</p><h3 id="운동"><a href="#운동" class="headerlink" title="운동"></a>운동</h3><p>앉아있는 시간이 많아서 점점 몸무게가 증가하길래 운동을 시작한지 어느새 반 년 정도 되었다. 많이 뺀 건 아니고 대략 8kg 정도 뺐는데, 빠르지는 않지만 그래도 꾸준히 빠지고 있어서 뿌듯하다. 운동하면서 약간의 활력과 체력이 생겨서 생활하는 데에 도움이 되고 있는 것 같다. 물론 운동은, 언제해도 힘들긴 하다…</p><h2 id="회고를-마치며"><a href="#회고를-마치며" class="headerlink" title="회고를 마치며"></a>회고를 마치며</h2><p>이번 2019년도 2분기는 전체적으로 소모된 에너지를 충전하는 느낌으로 지낸 시간이 많았다. 사실 요 근래 개인적인 일들 때문에 약간의 슬럼프가 와서 개발이 손에 안 잡히는 경험도 있었고, 프로젝트의 중추를 맡다보니 개인의 개발 업무뿐 아니라 신경 쓸 부분이 많다는 것에 대해 압박감을 느끼기도 했다.</p><p>그래도 이런 과정에서 나에 대해 인정해주는 사람들이 많아서 고생한 것들이 헛된 게 아니구나, 하는 뿌듯함과 함께 아직은 이런 성장통을 겪는 게 당연하다, 라는 생각이 들었다.</p><p>아직 남은 절반의 올 해를 위해서, 비록 빠르게 달리지 못하더라도 꾸준히 걷기 위한 힘을 비축했다고 생각하도록 하자. 힘내라, 나 자신!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/clock.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;2019년이 절반이 지난 시점(벌써 20일 넘게 지났지만…), 지난번 1분기 회고에 이어서 2분기 회고를 한 번 해보자.&lt;/p&gt;
&lt;h2 id=&quot;회사&quot;&gt;&lt;a href=&quot;#회사
      
    
    </summary>
    
    
      <category term="Retrospective" scheme="https://jheloper.github.io/tags/Retrospective/"/>
    
  </entry>
  
  <entry>
    <title>자바의 제네릭에 대해서 - 실전편(2)</title>
    <link href="https://jheloper.github.io/2019/07/java-generics-03/"/>
    <id>https://jheloper.github.io/2019/07/java-generics-03/</id>
    <published>2019-07-14T14:50:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java-logo.jpg" alt></p><p><a href="/2019/07/java-generics-02">이전 포스트</a>에 이어서 자바의 제네릭을 실제로 활용하는 내용에 대해서 정리해보자.</p><h2 id="와일드카드-타입-Wildcard-type"><a href="#와일드카드-타입-Wildcard-type" class="headerlink" title="와일드카드 타입(Wildcard type)"></a>와일드카드 타입(Wildcard type)</h2><p>이전 포스트까지 읽었다면 제네릭을 선언하여 코드 내에서 사용하고, 클라이언트 코드에서 구체적 타입을 지정하는 방법들은 알게 되었다. 그런데 또 하나, 만약 제네릭을 메서드의 파라미터로 주고 받는 경우에는 어떻게 해야할까? 또 하나의 예제를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printElements</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 List 인터페이스 구현체 객체를 파라미터로 받아서 요소를 출력하는 간단한 정적 제네릭 메서드를 가진 ListUtil 클래스다. 자, 이 간단한 메서드의 기능을 테스트해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ListUtil.&lt;Number&gt;printElements(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListUtil 클래스의 제네릭 메서드에 구체적 타입으로 Number를 지정했고, 파라미터로 전달한 객체 역시 <code>List&lt;Number&gt;</code> 타입이기 때문에 위 테스트 코드는 문제없이 통과한다. 그렇다면 조금 바꿔보도록 하자. <code>final List&lt;Number&gt; list = new ArrayList&lt;&gt;();</code> 부분에서 List의 타입 파라미터를 Number가 아닌 Integer로 바꾼다면 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ListUtil.&lt;Number&gt;printElements(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드 역시 문제없이 실행되어야 하지 않을까? 그러나 안타깝게도 위 코드는 컴파일 오류가 발생한다. 왜일까?</p><p>이는 자바의 제네릭 특성 상, <strong>파라미터화 타입(parameterized type)</strong>인 <code>List&lt;Number&gt;</code>와 <code>List&lt;Integer&gt;</code> 간의 관계는 <strong>구체적 타입인 Number와 Integer 간의 관계와는 무관</strong>하기 때문이다. 따라서 제네릭 메서드에 구체적 타입으로 Number를 지정했다면 파라미터로 가능한 것은 <code>List&lt;Integer&gt;</code>가 아닌 <code>List&lt;Number&gt;</code>이다.</p><p>그런데 만약, 해당 제네릭 메서드에 파라미터로 지정할 List가 Number도 있고, Integer도 있고, Double도 있다면 어떻게 해야 할까? ListUtil 클래스의 printElements 메서드를 아래와 같이 수정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printElements</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어느 부분이 바뀌었는지 보이는가? 원래 제네릭 메서드였지만, 이제는 평범한 정적 메서드처럼 보인다. 하나 특이한 것이라면, 메서드의 파라미터가 <code>List&lt;?&gt;</code>로 지정되어 있다는 점이다.</p><p>이쯤에서 <strong>와일드카드 타입(Wildcard type)</strong>에 대해서 얘기해보자. 위처럼 제네릭 타입 또는 제네릭 메서드가 메서드의 파라미터로 구체적 타입을 받아들일 때, <strong>모든 클래스와 인터페이스 타입을 허용하는 특별한 타입인 와일드카드 타입을 사용</strong>할 수 있다.</p><p>그렇다면 저렇게 와일드카드 타입으로 바꾼 메서드는 <code>List&lt;Integer&gt;</code>를 파라미터로 받아들일 수 있을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 보통의 정적 메서드가 되었기 때문에 구체적 타입을 지정하던 부분은 삭제</span></span><br><span class="line">    ListUtil.printElements(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 코드를 위처럼 수정하고 실행해보면 정상적으로 동작함을 알 수 있다.</p><h2 id="한정적-와일드카드-타입-Bounded-wildcard-type"><a href="#한정적-와일드카드-타입-Bounded-wildcard-type" class="headerlink" title="한정적 와일드카드 타입(Bounded wildcard type)"></a>한정적 와일드카드 타입(Bounded wildcard type)</h2><p>와일드카드 타입을 사용해서 유연성을 확보한 것은 좋지만, 한 가지 꺼림칙한 점이 있다. 유연해도 너무 유연하다. 예를 들어 위 예제에서 누군가의 실수로 파라미터로 <code>List&lt;Integer&gt;</code> 대신 <code>List&lt;Object&gt;</code>을 넣었다고 가정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ListUtil.printElements(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그래도 정상적으로 컴파일 되고 실행 결과도 동일하다. 그러나 의도한 바는 아니다. 작성자의 의도가 만약 *”Number 클래스와 그 하위 클래스들의 List 구현체만을 파라미터로 받고 싶다”* 라면 위 테스트 코드는 실패한 것이다.</p><p>그런데 와일드카드 타입은 위에서 설명했던 것처럼 모든 클래스와 인터페이스 타입을 허용한다. 그렇다면 와일드카드 타입의 허용 범위를 제한할 방법은 없을까? 다행히도, 방법이 있다. <strong>한정적 와일드카드 타입(Bounded wildcard type)</strong>을 사용하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumberExtendElements</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 ListUtil 클래스에 추가한 printNumberExtendElements 메서드인데, 어떤 차이점이 있는지 알아챘는가? 와일드카드 <code>?</code> 뒤에 <code>extends</code> 키워드가 붙어있고 그 뒤에는 Number 클래스가 지정되어 있다. 이것이 바로 한정적 와일드카드 타입을 적용했을 때의 코드이며, printNumberExtendElements 메서드에 파라미터로 넘어오는 List의 타입 파라미터 구체적 타입을 Number 또는 Number의 하위 클래스로 제한한 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNumberExtendElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">1L</span>);</span><br><span class="line">    list.add(<span class="number">2L</span>);</span><br><span class="line">    list.add(<span class="number">3L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 컴파일 오류 발생</span></span><br><span class="line">    ListUtil.printNumberExtendElements(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>한정적 와일드카드 타입을 적용한 printNumberExtendElements 메서드에 <code>List&lt;Object&gt;</code>를 사용한 테스트 코드를 실행하려고 하면 컴파일 오류가 발생한다. 이렇게 와일드카드 타입에 허용되는 구체적 타입을 제한할 수 있다.</p><p>한정적 와일드카드 타입에는 2가지의 키워드를 사용할 수 있는데, <code>extends</code>와 <code>super</code>다. 이 키워드들의 차이점은 <code>extends</code> 키워드를 사용하면 <strong>상향 한정적 와일드카드 타입(Upper bounded wildcard type)</strong>, <code>super</code> 키워드를 사용하면 <strong>하향 한정적 와일드카드 타입(Lower bounded wildcard type)</strong>이라는 것이다.</p><p>지금 printNumberExtendElements 메서드는 List 인터페이스의 구현체를 파라미터로 받을 때 타입 파라미터를 와일드카드 타입으로 받되 Number 또는 Number의 하위 클래스만을 허용하도록 되어있다. 그런데 만약, Integer 또는 Integer의 상위 클래스만을 허용하는 새로운 메서드를 추가하고 싶다면?</p><p>아래 메서드를 ListUtil에 추가해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printIntegerSuperElements</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>차이점은 한정적 와일드카드 타입을 사용한 부분을 <code>extends</code>가 아닌 <code>super</code>로, 와일드카드 타입에 허용되는 구체적 타입이 Integer이라는 것뿐이다.</p><p>테스트 코드를 작성해서 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printIntegerSuperElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;Long&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">1L</span>);</span><br><span class="line">    list.add(<span class="number">2L</span>);</span><br><span class="line">    list.add(<span class="number">3L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 컴파일 오류 발생</span></span><br><span class="line">    ListUtil.printIntegerSuperElements(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트 코드는 역시 컴파일 오류가 발생한다. 왜냐하면 한정적 와일드카드로 Integer 또는 Integer의 상위 클래스만을 받도록 제한했기 때문이다. Long 타입은 printIntegerSuperElements 메서드에 지정된 한정적 와일드카드 타입의 허용 범위에 포함되지 않는다.</p><h2 id="제네릭-타입의-상속과-구현"><a href="#제네릭-타입의-상속과-구현" class="headerlink" title="제네릭 타입의 상속과 구현"></a>제네릭 타입의 상속과 구현</h2><p><strong>제네릭 타입 역시 상속 및 구현이 가능</strong>하다. 먼저 제네릭 클래스의 상속부터 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentStorage</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T primaryData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> U secondaryData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getPrimaryData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> primaryData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryData</span><span class="params">(T primaryData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.primaryData = primaryData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> U <span class="title">getSecondaryData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secondaryData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecondaryData</span><span class="params">(U secondaryData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secondaryData = secondaryData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 ParentStorage 클래스는 간단한 클래스로 2종류의 데이터를 저장하는 기능이 있는데, 저장하는 데이터의 타입을 지정하기 위해 2개의 타입 파라미터를 받고 있다. 그런데 ParentStorage의 기능을 그대로 사용하면서 3번째 데이터를 저장하는 ChildStorage 클래스를 구현하고 싶다면 상속을 이용하는 것이 좋지 않을까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildStorage</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ParentStorage</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V tertiaryData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getTertiaryData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tertiaryData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTertiaryData</span><span class="params">(V tertiaryData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tertiaryData = tertiaryData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 ChildStorage 클래스는 ParentStorage 클래스를 상속하면서 총 3개의 타입 파라미터가 선언되어 있다. 그 중 2개의 타입 파라미터는 ParentStorage 클래스의 타입 파라미터로 넘기고 있으며, 나머지 1개의 타입 파라미터는 3번째 데이터의 타입으로 지정했다.</p><p>자, 정상적으로 동작하는지 테스트 코드를 작성해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildStorageTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createChildStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String primaryData = <span class="string">"this is primary data."</span>;</span><br><span class="line">        <span class="keyword">final</span> Integer secondaryData = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> Double tertiaryData = <span class="number">5.5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ChildStorage&lt;String, Integer, Double&gt; childStorage = <span class="keyword">new</span> ChildStorage&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        childStorage.setPrimaryData(primaryData);</span><br><span class="line">        childStorage.setSecondaryData(secondaryData);</span><br><span class="line">        childStorage.setTertiaryData(tertiaryData);</span><br><span class="line"></span><br><span class="line">        Assert.assertNotNull(childStorage);</span><br><span class="line">        Assert.assertEquals(primaryData, childStorage.getPrimaryData());</span><br><span class="line">        Assert.assertEquals(secondaryData, childStorage.getSecondaryData());</span><br><span class="line">        Assert.assertEquals(tertiaryData, childStorage.getTertiaryData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 코드를 실행해보면 기대한 결과대로 동작한다. 그럼 이제 제네릭 인터페이스의 구현을 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StorageType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(T data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StorageType 인터페이스는 우리가 몇 번이나 예제로 써먹었던 Storage 클래스들의 기본적인 기능을 공통화한 제네릭 인터페이스다. 이것을 구현하는 클래스를 한 번 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">StorageType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제로 사용하는 예제를 위해 테스트 코드를 작성해보자. 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String data = <span class="string">"this is data."</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> StorageType&lt;String&gt; storage = <span class="keyword">new</span> StorageImpl&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        storage.set(data);</span><br><span class="line"></span><br><span class="line">        Assert.assertNotNull(storage);</span><br><span class="line">        Assert.assertEquals(data, storage.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자, 이렇게 제네릭 인터페이스를 선언하고 그것을 구현하는 클래스의 예제를 만들어보았다. 위 테스트 코드를 실행하면? 기대한 바대로 테스트는 성공한다.</p><p>이것으로 자바의 제네릭에 대해서 실전편을 마무리하자.</p><blockquote><p>포스트에서 사용한 예제 코드는 <a href="https://github.com/jheloper/java-playground" target="_blank" rel="noopener">여기</a>에서도 확인할 수 있습니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/java-logo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2019/07/java-generics-02&quot;&gt;이전 포스트&lt;/a&gt;에 이어서 자바의 제네릭을 실제로 활용하는 내용에 대해서 정리해보자.&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Java" scheme="https://jheloper.github.io/tags/Java/"/>
    
      <category term="GenericProgramming" scheme="https://jheloper.github.io/tags/GenericProgramming/"/>
    
  </entry>
  
  <entry>
    <title>자바의 제네릭에 대해서 - 실전편(1)</title>
    <link href="https://jheloper.github.io/2019/07/java-generics-02/"/>
    <id>https://jheloper.github.io/2019/07/java-generics-02/</id>
    <published>2019-07-07T14:55:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java-logo.jpg" alt></p><p><a href="/2019/06/java-generics-01">이전 포스트</a>에 이어서 자바의 제네릭을 실제로 활용하는 내용에 대해서 정리해보자.</p><h2 id="제네릭-타입-Generic-Type"><a href="#제네릭-타입-Generic-Type" class="headerlink" title="제네릭 타입(Generic Type)"></a>제네릭 타입(Generic Type)</h2><p>제네릭 타입은 타입을 파라미터로 가지는 클래스, 또는 인터페이스를 의미한다. 이론편에서 봤던 예제를 다시 한번 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericStorage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T storedData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getStoredData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStoredData</span><span class="params">(T storedData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storedData = storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 보면 GenericStorage 클래스명 뒤에 <code>&lt;&gt;</code> 부호가 붙어있으며 이 안에 <code>T</code>가 선언되어 있는데, 이 <code>T</code>를 <strong>타입 파라미터</strong>라고 한다.</p><p>타입 파라미터의 이름은 변수명과 동일한 룰에 따라 작성할 수 있으나 <em>일반적으로 대문자 알파벳 한 글자로 표현하는 것이 관례</em>이다. 이렇게 제네릭 타입에 사용된 타입 파라미터는 제네릭 타입 내의 코드에서 사용할 수 있다.</p><p>그렇다면 제네릭 타입의 선언은 위와 같이 했는데, 사용할 때에는 어떻게 사용해야 하는 걸까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericStorageTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetStoredDataWithMultipleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Integer data = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// final String data = "this is data.";</span></span><br><span class="line">        <span class="comment">// final Double data = 3.14;</span></span><br><span class="line"></span><br><span class="line">        GenericStorage&lt;Integer&gt; storage = <span class="keyword">new</span> GenericStorage&lt;&gt;();</span><br><span class="line">        <span class="comment">// GenericStorage&lt;String&gt; storage = new GenericStorage&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// GenericStorage&lt;Double&gt; storage = new GenericStorage&lt;&gt;();</span></span><br><span class="line">        storage.setStoredData(data);</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(data, storage.getStoredData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드 역시 이전 포스트에서 사용한 테스트 코드이다. 위 테스트 코드를 보면 제네릭 타입을 실제로 사용할 때에는 어떻게 사용하는지 알 수 있는데, 사실 여기서는 생략된 부분이 있다.</p><p>제네릭 타입 변수를 선언하고 인스턴스를 생성하는 코드인 <code>GenericStorage&lt;Integer&gt; storage = new GenericStorage&lt;&gt;();</code> 에서 보면, 인스턴스를 생성할 때에 <code>new GenericStorage&lt;&gt;();</code> 라는 코드로 인스턴스를 생성하고 있다. 원래는 제네릭 타입 변수를 선언할 때처럼 <code>new GenericStorage&lt;Integer&gt;();</code> 와 같이 구체적 타입을 지정해야 하지만 자바 7부터 제네릭 타입의 인스턴스 생성 시 구체적 타입을 생략한 <strong>다이아몬드 연산자(diamond operator)</strong>를 지원한다.</p><h2 id="멀티-타입-파라미터-Multi-Type-Parameter"><a href="#멀티-타입-파라미터-Multi-Type-Parameter" class="headerlink" title="멀티 타입 파라미터(Multi Type Parameter)"></a>멀티 타입 파라미터(Multi Type Parameter)</h2><p>그런데 이 GenericStorage 클래스를 사용하다보니 또 다른 요구 사항이 발생했다, 라고 가정해보자. 이 하나의 클래스에 1종류의 데이터만 담고 있었는데, 또 다른 종류의 데이터도 함께 담고 싶다는 것이었다. 그럼 어떻게 해야 할까? 더군다나 지금은 제네릭 타입으로 바꾼 상태인데?</p><p>다행히도 제네릭의 <em>타입 파라미터는 여러 개를 선언할 수 있으며</em>, 이를 <strong>멀티 타입 파라미터</strong>라고 표현할 수 있다. 아래와 같이 변경해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericStorage</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T storedData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> U secondaryData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getStoredData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStoredData</span><span class="params">(T storedData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storedData = storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> U <span class="title">getSecondaryData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> secondaryData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecondaryData</span><span class="params">(U secondaryData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secondaryData = secondaryData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 멀티 타입 파라미터를 사용한 경우, 테스트 코드는 아래와 같이 수정할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetInGenericStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Integer data = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> String secondaryData = <span class="string">"this is data."</span>;</span><br><span class="line"></span><br><span class="line">    GenericStorage&lt;Integer, String&gt; storage = <span class="keyword">new</span> GenericStorage&lt;&gt;();</span><br><span class="line">    storage.setStoredData(data);</span><br><span class="line">    storage.setSecondaryData(secondaryData);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(data, storage.getStoredData());</span><br><span class="line">    Assert.assertEquals(secondaryData, storage.getSecondaryData());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자, 이제 위의 요구 사항이었던 또 다른 종류의 데이터를 담을 수 있는 GenericStorage 클래스가 되었다.</p><h2 id="제네릭-메서드-Generic-Method"><a href="#제네릭-메서드-Generic-Method" class="headerlink" title="제네릭 메서드(Generic Method)"></a>제네릭 메서드(Generic Method)</h2><p>반드시 클래스 또는 인터페이스 선언에서만 제네릭을 선언할 수 있는 것은 아니다. 메서드에도 제네릭을 적용하여 제네릭 메서드를 사용할 수 있다. 아래 예제를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">wrapList</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(e);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 파라미터 타입과 리턴 타입에 타입 파라미터를 가지는 메서드를 제네릭 메서드라고 한다.</p><p>리턴 타입 앞에 <code>&lt;&gt;</code>를 추가하고 <em>타입 파라미터를 선언</em>하며, <em>리턴 타입과 파라미터 타입에 선언한 타입 파라미터를 사용할 수 있다</em>. 또한 제네릭 타입과 마찬가지로 멀티 타입 파라미터도 가능하다. 이렇게 제네릭 메서드에 선언한 타입 파라미터는 해당 메서드 내에서만 유효하다.</p><p>제네릭 메서드를 사용하는 테스트 코드는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrapList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String data = <span class="string">"this is data."</span>;</span><br><span class="line"></span><br><span class="line">    GenericStorage&lt;Integer, Double&gt; storage = <span class="keyword">new</span> GenericStorage&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; stringList = storage.&lt;String&gt;wrapList(data);</span><br><span class="line">    <span class="comment">// final List&lt;String&gt; stringList = storage.wrapList(data);</span></span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(data, stringList.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 실제로 제네릭 메서드를 사용한 부분은 <code>final List&lt;String&gt; stringList = storage.&lt;String&gt;wrapList(data);</code> 인데, 여기서 제네릭 메서드를 호출할 때 구체적 타입을 명시함을 알 수 있다. 그러나 구체적 타입을 생략하고 <code>final List&lt;String&gt; stringList = storage.wrapList(data);</code> 와 같은 방법으로 호출하더라도 파라미터의 타입을 통해 구체적 타입을 추정한다.</p><h2 id="한정적-타입-파라미터-Bounded-Type-Parameter"><a href="#한정적-타입-파라미터-Bounded-Type-Parameter" class="headerlink" title="한정적 타입 파라미터(Bounded Type Parameter)"></a>한정적 타입 파라미터(Bounded Type Parameter)</h2><p><em>필요에 따라 타입 파라미터의 범위를 한정해야 하는 경우</em>가 있다. 그럴 때에는 <strong>한정적 타입 파라미터</strong>를 선언할 수 있다.</p><p>한정적 타입 파라미터를 사용하는 예제를 위해, Beverage 클래스와 그 하위 클래스를 보관할 수 있는 BeverageStorage 클래스를 만들어달라는 요구 사항이 생겼다고 가정해보자. 먼저 Beverage 클래스와 그 하위 클래스들부터 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실제 코드는 각각 클래스 파일을 나눠서 작성했다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is beverage."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is coke."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is coffee."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beer</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is beer."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자, 다음은 BeverageStorage 클래스를 만들어보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeverageStorage</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Beverage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T beverage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeverage</span><span class="params">(T beverage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 핵심은 한정적 타입 파라미터를 사용한 <code>&lt;T extends Beverage&gt;</code> 부분이다. 타입 파라미터를 선언할 때 <code>extends</code> 키워드를 사용하여 상위 타입을 지정하면 해당 타입 파라미터의 구체적 타입은 지정한 상위 타입 및 상위 타입을 상속(또는 구현)하는 하위 타입으로만 한정할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeverageStorageTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Beverage beverage = <span class="keyword">new</span> Beverage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BeverageStorage&lt;Beverage&gt; beverageStorage = <span class="keyword">new</span> BeverageStorage&lt;&gt;();</span><br><span class="line">        beverageStorage.setBeverage(beverage);</span><br><span class="line"></span><br><span class="line">        beverageStorage.getBeverage().drink();</span><br><span class="line">        Assert.assertEquals(beverage, beverageStorage.getBeverage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetCoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Coke coke = <span class="keyword">new</span> Coke();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BeverageStorage&lt;Coke&gt; cokeStorage = <span class="keyword">new</span> BeverageStorage&lt;&gt;();</span><br><span class="line">        cokeStorage.setBeverage(coke);</span><br><span class="line"></span><br><span class="line">        cokeStorage.getBeverage().drink();</span><br><span class="line">        Assert.assertEquals(coke, cokeStorage.getBeverage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Coffee coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BeverageStorage&lt;Coffee&gt; coffeeStorage = <span class="keyword">new</span> BeverageStorage&lt;&gt;();</span><br><span class="line">        coffeeStorage.setBeverage(coffee);</span><br><span class="line"></span><br><span class="line">        coffeeStorage.getBeverage().drink();</span><br><span class="line">        Assert.assertEquals(coffee, coffeeStorage.getBeverage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetBeer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Beer beer = <span class="keyword">new</span> Beer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BeverageStorage&lt;Beer&gt; beerStorage = <span class="keyword">new</span> BeverageStorage&lt;&gt;();</span><br><span class="line">        beerStorage.setBeverage(beer);</span><br><span class="line"></span><br><span class="line">        beerStorage.getBeverage().drink();</span><br><span class="line">        Assert.assertEquals(beer, beerStorage.getBeverage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 테스트 코드와 같이 <strong>Beverage 클래스 및 그 하위 클래스만을 타입 파라미터의 구체적 타입으로 지정</strong>할 수 있다. 만약 다른 클래스를 구체적 타입으로 지정한다면 컴파일 오류가 발생한다.</p><blockquote><p>자바의 제네릭에 대해 다루는 내용이 길어져 다음 포스트로 내용을 이어갑니다.<br>포스트에서 사용한 예제 코드는 <a href="https://github.com/jheloper/java-playground" target="_blank" rel="noopener">여기</a>에서도 확인할 수 있습니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/java-logo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2019/06/java-generics-01&quot;&gt;이전 포스트&lt;/a&gt;에 이어서 자바의 제네릭을 실제로 활용하는 내용에 대해서 정리해보자.&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="Java" scheme="https://jheloper.github.io/tags/Java/"/>
    
      <category term="GenericProgramming" scheme="https://jheloper.github.io/tags/GenericProgramming/"/>
    
  </entry>
  
  <entry>
    <title>자바의 제네릭에 대해서 - 이론편</title>
    <link href="https://jheloper.github.io/2019/06/java-generics-01/"/>
    <id>https://jheloper.github.io/2019/06/java-generics-01/</id>
    <published>2019-06-30T14:50:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java-logo.jpg" alt></p><h2 id="제네릭-프로그래밍-Generic-Programming"><a href="#제네릭-프로그래밍-Generic-Programming" class="headerlink" title="제네릭 프로그래밍(Generic Programming)?"></a>제네릭 프로그래밍(Generic Programming)?</h2><p>자바의 제네릭에 대해서 알아보기에 앞서, 제네릭 프로그래밍이 무엇인지부터 알아보자.</p><p>위키피디아에서 아래와 같이 설명하고 있다.</p><blockquote><p>“데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있는 기술에 중점을 두어 재사용성을 높일 수 있는 프로그래밍 방식”</p></blockquote><p>쉽게 표현해보자면, <strong>어떤 알고리즘을 수행하는 코드가 있다고 했을 때, 특정 데이터 타입에 종속적이지 않고 코드가 범용성과 재사용성을 가질 수 있게 하는 프로그래밍 방식</strong>이라고 할 수 있겠다.</p><h2 id="왜"><a href="#왜" class="headerlink" title="왜?"></a>왜?</h2><p>그렇다면 자바는 왜 제네릭이 필요했을까?</p><p>그 필요성을 알기 위해 예를 들고자 아래와 같은 코드가 있다고 가정해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object storedData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getStoredData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStoredData</span><span class="params">(Object storedData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storedData = storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>간단한 클래스인데, 특정 데이터를 담아두는 용도로 사용할 Storage 클래스이다. 다만 들어갈 데이터의 타입이 고정적이지 않고 유동적일 수 있다는 요구 사항이 있어서 필드 타입을 <code>Object</code> 로 지정했다. <code>Object</code> 타입은 모든 클래스의 최상위 타입이기 때문에 어떤 타입의 객체도 할당할 수 있기 때문이다.</p><p>자, 정상적으로 동작하는지 테스트 코드를 작성해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetStoredData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String data = <span class="string">"this is data."</span>;</span><br><span class="line"></span><br><span class="line">        Storage storage = <span class="keyword">new</span> Storage();</span><br><span class="line">        storage.setStoredData(data);</span><br><span class="line"></span><br><span class="line">        String storedData = storage.getStoredData();</span><br><span class="line">        Assert.assertEquals(data, storedData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전혀 문제없어 보이는 코드 같은가? 하지만 사실 이 테스트 코드는 실행되지 않고 <strong>컴파일 에러가 발생</strong>한다. 문제가 되는 부분은 바로 <code>String storedData = storage.getStoredData();</code> . 왜냐하면 Storage 클래스의 <code>getStoredData</code> 메서드는 <code>String</code> 타입을 반환하는 게 아니라 <code>Object</code> 타입을 반환하도록 만들어져 있기 때문이다.</p><p>그럼 <code>Object</code> 타입을 <code>String</code> 타입으로 캐스팅하는 코드로 바꿔보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StorageTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetStoredData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String data = <span class="string">"this is data."</span>;</span><br><span class="line"></span><br><span class="line">        Storage storage = <span class="keyword">new</span> Storage();</span><br><span class="line">        storage.setStoredData(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 차이점이 잘 보이지 않을 수 있으나 여기에 String 타입으로 캐스팅하는 코드가 추가됐다.</span></span><br><span class="line">        String storedData = (String) storage.getStoredData();</span><br><span class="line">        Assert.assertEquals(data, storedData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 테스트 코드를 실행해보면 정상적으로 실행되고 테스트는 무사히 통과한다. 이대로 만만세일까? 아니, 그렇지 않다.</p><p>Storage 클래스의 storedData 필드는 들어갈 수 있는 타입이 유동적이기 때문에 <code>Object</code> 타입으로 지정했다. 유동적으로 어떤 타입이든 storedData 필드에 넣을 수 있는 것은 원하던 바다. 다만, storedData 필드에 Object 타입이 아닌 다른 타입의 객체를 할당한다면 결국 <strong>묵시적 캐스팅이 발생</strong>하며, storedData 필드를 가져와서 사용할 때에는 사용하려는 타입에 대한 <strong>명시적 캐스팅이 필요</strong>하다. <code>Object</code> 타입 그대로의 객체가 필요한 것이 아니라면 말이다.</p><p>위 테스트 코드는 <code>String</code> 타입 하나에 대한 예제 코드인데, 만약 여러 타입이 들어갈 수 있는 경우에 대한 테스트 코드를 작성하면 어떻게 될까? 한 번 작성해보도록 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetStoredDataWithMultipleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 타입과 값을 String이나 Double로 바꿔서 테스트해도 문제없이 성공한다.</span></span><br><span class="line">    <span class="keyword">final</span> Integer data = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// final String data = "this is data."</span></span><br><span class="line">    <span class="comment">// final Double data = 3.14;</span></span><br><span class="line"></span><br><span class="line">    Storage storage = <span class="keyword">new</span> Storage();</span><br><span class="line">    storage.setStoredData(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(storage.getStoredData() <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String storedData = (String) storage.getStoredData();</span><br><span class="line">        Assert.assertEquals(data, storedData);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(storage.getStoredData() <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Integer storedData = (Integer) storage.getStoredData();</span><br><span class="line">        Assert.assertEquals(data, storedData);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(storage.getStoredData() <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Double storedData = (Double) storage.getStoredData();</span><br><span class="line">        Assert.assertEquals(data, storedData);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Assert.fail(<span class="string">"unsupported type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>일단 가능한 타입이 <code>String</code>, <code>Integer</code>, <code>Double</code> 3가지만 가정하더라도 이런 형태의 코드가 만들어진다. 가능한 타입에 대한 분기와 해당 타입에 대한 캐스팅하는 코드가 반복되고 있는 모습을 볼 수 있다. 코드가 데이터 타입에 종속적이라면 이와 같이 중복 코드가 발생할 수 있다.</p><p>즉, 자바가 제네릭 프로그래밍 방식을 도입하기 위해서(=코드가 타입이 종속적이지 않고 범용성과 재사용성을 확보할 수 있게 하기 위해서) Object 타입 또는 특정 상위 타입을 사용하는 것은 다음과 같은 한계들이 있다.</p><ol><li>필요한 타입으로 캐스팅하는 코드가 필요하고,</li><li>잘못된 타입으로 캐스팅하더라도 컴파일 단계에서 체킹 되지 않기 때문에 런타임 에러가 발생할 위험이 있으며,</li><li>잦은 타입 캐스팅은 성능에 영향을 끼친다.</li></ol><h2 id="그래서"><a href="#그래서" class="headerlink" title="그래서?"></a>그래서?</h2><p>그렇다면 자바의 제네릭은 위와 같은 한계들을 해결했을까?</p><p>확인해보기 위해 자바 5부터 추가된 제네릭 타입을 한 번 사용해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericStorage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T storedData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getStoredData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStoredData</span><span class="params">(T storedData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.storedData = storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 보면 낯선 표현들이 있을 것이다. 일단 클래스 이름 뒤에 붙은 <code>&lt;T&gt;</code>. 이것은 해당 클래스에서 사용할 제네릭 타입을 선언한 것이다. 제네릭 타입을 선언할 때 사용한 <code>&lt;&gt;</code> 는 다이아몬드 연산자(diamond operator)이며, 대문자 <code>T</code> 는 타입 파라미터(type parameter)로, 타입 파라미터는 <strong>클라이언트 코드에서 GenericStorage 클래스를 사용할 때 할당하는 타입으로 바뀌는 플레이스홀더(placeholder) 같은 역할</strong>을 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericStorageTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndGetStoredDataWithMultipleTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Integer data = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// final String data = "this is data."</span></span><br><span class="line">        <span class="comment">// final Double data = 3.14;</span></span><br><span class="line"></span><br><span class="line">        GenericStorage&lt;Integer&gt; storage = <span class="keyword">new</span> GenericStorage&lt;&gt;();</span><br><span class="line">        <span class="comment">// GenericStorage&lt;String&gt; storage = new GenericStorage&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// GenericStorage&lt;Double&gt; storage = new GenericStorage&lt;&gt;();</span></span><br><span class="line">        storage.setStoredData(data);</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(data, storage.getStoredData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>테스트 코드는 정상적으로 실행된다! 그러면 실제로 위에서 얘기했던 한계들이 해결되었나 확인해보자.</p><ol><li>필요한 타입으로 캐스팅하는 코드가 필요하지 않고,</li><li>컴파일 단계에서 타입 체킹이 가능하며,</li><li>타입 캐스팅을 하지 않기 때문에 성능상으로도 이점을 얻을 수 있다.</li></ol><p>그렇다, 자바의 제네릭은 위에서 얘기했던 한계들을 해결했다. 이것으로 일단 자바의 제네릭에 대한 이론적인 설명은 이쯤에서 마무리하고 다음 포스트에서 자바의 제네릭을 어떻게 사용할 수 있는지 본격적으로 알아보도록 하자.</p><p>포스트에서 사용한 예제 코드는 <a href="https://github.com/jheloper/java-playground" target="_blank" rel="noopener">여기</a>에서도 확인할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/java-logo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;제네릭-프로그래밍-Generic-Programming&quot;&gt;&lt;a href=&quot;#제네릭-프로그래밍-Generic-Programming&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Java" scheme="https://jheloper.github.io/tags/Java/"/>
    
      <category term="GenericProgramming" scheme="https://jheloper.github.io/tags/GenericProgramming/"/>
    
  </entry>
  
  <entry>
    <title>Early Return 하는 코드를 작성하자</title>
    <link href="https://jheloper.github.io/2019/06/write-early-return-code/"/>
    <id>https://jheloper.github.io/2019/06/write-early-return-code/</id>
    <published>2019-06-16T14:20:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/code-screen.jpg" alt></p><p>일하면서 어떤 조건문을 작성하다 보니 아래와 같은 코드를 작성하게 되었다(실제 코드를 실을 수는 없기 때문에 일단 구조만 가져왔다).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (id &gt; <span class="number">10</span>) &#123;</span><br><span class="line">value = <span class="string">"Id is greater than 10."</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">value = <span class="string">"Id is greater than 0 and below 10."</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">value = <span class="string">"This id is zero."</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">value = <span class="string">"Invalid id."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런데 작성하고 보니 뭔가 마음에 들지 않는 코드였다. 분명 내가 의도한 바를 실행하는 코드이기는 하지만, 뭔가 자연스럽게 읽기 어려운 코드라는 생각이 들었다.</p><p>그래서 아래와 같이 <strong>Early Return</strong> 하는 코드로 바꿨다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"This id is zero."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid id."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Id is greater than 10."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Id is greater than 0 and below 10."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그런데 <strong>Early Return</strong> 이란 무엇일까?</p><p>구글에서 검색하다가 <a href="http://blog.timoxley.com/post/47041269194/avoid-else-return-early" target="_blank" rel="noopener">이러한 글</a>을 발견했다. 여기서 <strong>Early Return</strong> 에 대해서 설명하고 있는데, 그 내용을 대략적으로 설명하자면 아래와 같다(아래 내용은 글의 전체 내용이 아닌 일부만 발췌하여 의역했으며, 해당 글의 내용 전부에 동의하지는 않는다).</p><blockquote><p>종종 프로그래머에게 “메서드 내의 결과를 반환하는 부분을 오직 한 군데에서만 하도록(single exit point라고 해당 글의 필자는 표현하고 있다)” 하는 경우가 있는데, 이는 <em>빈곤한 가이드라인(poor guideline이라고 되어 있는데, 적당한 번역인지는 모르겠다…)</em>이다.</p></blockquote><blockquote><p>“결과를 할당하는 것”은 “이게 최종 값이며, 처리는 여기서 멈춘다”라는 의도를 설명하지 않으며, “이 결과는 완료된거야? 수정할 수 있는거야?”라는 질문을 남기고, 결과를 수정하는 실수를 허용하기도 한다. 그러므로 함수가 더 이상 의미있는 동작을 하지 않는다는 것을 알자마자 반환하고, <code>if/else</code> 대신에 <code>if/return</code> 구조를 사용하여 들여쓰기를 최소한으로 줄이자.</p></blockquote><p>내 생각에도 처음 작성했던 코드보다 <strong>Early Return</strong> 형태로 작성한 코드가 더 자연스럽게 읽혀지는 듯 하다. 아니, 읽히는 것도 그렇지만 의미도 명확하다. <code>if</code> 조건문에 들어오면 해당하는 동작을 하고 <code>return</code> 한다. 이 함수에서 더 이상의 동작은 없다. 이 함수가 어떤 조건일 때 무엇을 반환하는지 매우 명확하다. 또한 아래에 누군가가 실수로 결과를 수정하려는 코드를 넣는다고 해도 안전하다.</p><p>물론 <strong>Early Return</strong> 하는 코드를 작성할 때에는 유의할 것이 있다. 조건문의 범위 및 순서를 잘 고려하면서 배치하지 않으면 망한다(!). 만약 아래와 같이 코드를 수정했다면 원래 실행에 문제 없었던 동작에도 문제가 생겨버리는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 여기가 문제다. 바보 같지만 10보다 큰 값이 들어와도 이 조건문 안에서 끝나버린다...</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Id is greater than 0 and below 10."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"This id is zero."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Invalid id."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">"Id is greater than 10."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 정리해보면서 다시금 느끼지만, 읽기 좋은 코드를 작성하는 것은 정말 쉽지 않은 일인 것 같다. 언제쯤 자연스럽게 읽을 수 있는 코드를 작성할 수 있는 수준이 될 지 모르겠지만, 그래도 꾸준히 시도하다보면 언젠가 도달할 수 있지 않을까?</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/code-screen.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;일하면서 어떤 조건문을 작성하다 보니 아래와 같은 코드를 작성하게 되었다(실제 코드를 실을 수는 없기 때문에 일단 구조만 가져왔다).&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
      <category term="Refactoring" scheme="https://jheloper.github.io/tags/Refactoring/"/>
    
      <category term="Coding" scheme="https://jheloper.github.io/tags/Coding/"/>
    
  </entry>
  
  <entry>
    <title>자바 애플리케이션은 어떻게 실행되는걸까?</title>
    <link href="https://jheloper.github.io/2019/06/how-does-a-java-application/"/>
    <id>https://jheloper.github.io/2019/06/how-does-a-java-application/</id>
    <published>2019-06-15T06:50:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java-logo.jpg" alt></p><p>자바 애플리케이션을 구현하는 입장에서 자바 애플리케이션은 어떻게 실행되는 것일까 궁금하여 파악한 바를 간략하게 정리하고자 한다.</p><h2 id="자바-프로그래밍-언어로-소스-코드-java-를-작성한다"><a href="#자바-프로그래밍-언어로-소스-코드-java-를-작성한다" class="headerlink" title="자바 프로그래밍 언어로 소스 코드(.java)를 작성한다"></a>자바 프로그래밍 언어로 소스 코드(.java)를 작성한다</h2><p>가장 처음에 우리는 프로그래밍 언어인 자바로 소스 코드를 작성하는데, 이렇게 작성한 소스 코드 파일들은 <code>.java</code>라는 확장자가 붙은 파일들이다.</p><h2 id="소스-코드를-컴파일하여-바이트-코드-class-를-생성한다"><a href="#소스-코드를-컴파일하여-바이트-코드-class-를-생성한다" class="headerlink" title="소스 코드를 컴파일하여 바이트 코드(.class)를 생성한다"></a>소스 코드를 컴파일하여 바이트 코드(.class)를 생성한다</h2><p>우리가 작성한 소스 코드를 자바 컴파일러가 자바 가상 머신이 해석 가능한 바이트 코드로 컴파일하는데, 이렇게 컴파일된 바이트 코드 파일들은 <code>.class</code> 확장자가 붙은 파일들이다.</p><h2 id="자바-가상-머신-JVM-Java-Virtual-Machine-으로-자바-애플리케이션-프로세스를-생성한다"><a href="#자바-가상-머신-JVM-Java-Virtual-Machine-으로-자바-애플리케이션-프로세스를-생성한다" class="headerlink" title="자바 가상 머신(JVM, Java Virtual Machine)으로 자바 애플리케이션 프로세스를 생성한다"></a>자바 가상 머신(JVM, Java Virtual Machine)으로 자바 애플리케이션 프로세스를 생성한다</h2><p>자바 가상 머신(이하 JVM)을 통해 자바 애플리케이션을 실행하면 프로세스가 하나 생성되며, 동시에 운영체제로부터 메모리 영역을 할당 받는다.</p><p>JVM의 클래스 로더가 프로그램에 의해 호출되는 바이트 코드를 메모리에 적재하고 링크하며 초기화하고, 이 과정에서 운영체제로부터 할당받은 런타임 데이터 영역에 알맞게 데이터가 저장된다. 그리고 실행 엔진이 메모리에 적재된 바이트 코드를 읽고 해석하여 실행하면서 애플리케이션이 수행된다.</p><h3 id="클래스-로더"><a href="#클래스-로더" class="headerlink" title="클래스 로더"></a>클래스 로더</h3><p>바이트 코드인 클래스 파일을 읽어서 메모리에 적재하고, 링크하고, 초기화하는 역할을 한다. 이러한 클래스로더는 세부적으로 아래와 같이 분류할 수 있다.</p><ul><li>부트스트랩 클래스 로더 : 부트스트랩 클래스패스로부터 클래스들을 적재한다. 최상위 클래스 로더.</li><li>확장 클래스 로더 : 확장 경로(<code>jre/lib/ext</code> 폴더나 <code>java.ext.dirs</code> 환경변수에 지정된 경로)로부터 클래스들을 적재한다.</li><li>애플리케이션 클래스 로더 : 애플리케이션 레벨 클래스패스, 또는 기타 환경변수 경로로부터 클래스들을 적재한다.</li></ul><h3 id="런타임-데이터-영역"><a href="#런타임-데이터-영역" class="headerlink" title="런타임 데이터 영역"></a>런타임 데이터 영역</h3><p>자바 애플리케이션 프로세스가 운영체제에게 할당받은 런타임 메모리 영역. 아래와 같이 분류할 수 있다.</p><ul><li>매서드 영역 : 클래스 레벨 데이터(static 영역 포함)를 저장하는 영역. 프로세스마다 1개씩 존재. 공유 리소스이며 스레드 세이프하지 않다.</li><li>힙 영역 : 모든 객체와 배열이 저장되는 영역. 프로세스마다 1개씩 존재. 공유 리소스이며 스레드 세이프하지 않다.</li><li>스택 영역 : 각 스레드마다 가지는 영역, 메서드 호출에 대한 스택 프레임과 로컬 변수가 저장된다. 공유 불가능한 리소스이며 스레드 세이프하다.</li><li>PC 레지스터 : 각 스레드는 별도의 PC 레지스터를 가지며, 명령 실행 시 현재 실행중인 명령 주소를 저장한다.</li><li>네이티브 메서드 스택 : 네이티브 메서드 정보를 가지는 곳. 모든 스레드에 대해 별도의 네이티브 메서드 스택이 만들어진다.</li></ul><h3 id="실행-엔진"><a href="#실행-엔진" class="headerlink" title="실행 엔진"></a>실행 엔진</h3><p>바이트 코드를 읽고 해석하여 실행하는 역할을 한다. 아래는 실행 엔진에 포함된 컴포넌트들이다.</p><ul><li>인터프리터 : 바이트 코드를 하나씩 읽고 해석하여 실행하는 역할. 단점으로는 동일한 바이트 코드가 여러 번 호출되더라도 매번 새로운 해석이 발생한다는 것.</li><li>JIT(Just In Time) 컴파일러 : 인터프리터의 단점을 해소하기 위해 반복되는 코드를 발견하면 해당 바이트 코드를 컴파일하여 네이티브 코드로 변경하고 이를 반복적인 호출에 사용하여 시스템 성능을 향상시킨다.</li><li>가비지 컬렉터 : 더 이상 참조하지 않는 객체를 수집하고 힙 영역에서 제거하는 역할. 이런 과정은 JVM이 자동으로 수행한다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/java-logo.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;자바 애플리케이션을 구현하는 입장에서 자바 애플리케이션은 어떻게 실행되는 것일까 궁금하여 파악한 바를 간략하게 정리하고자 한다.&lt;/p&gt;
&lt;h2 id=&quot;자바-프로그래밍
      
    
    </summary>
    
    
      <category term="Java" scheme="https://jheloper.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://jheloper.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>스프링 부트 PID(Process Identifier) 파일 생성 방법</title>
    <link href="https://jheloper.github.io/2019/05/spring-boot-pid-file/"/>
    <id>https://jheloper.github.io/2019/05/spring-boot-pid-file/</id>
    <published>2019-05-17T15:10:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="왜"><a href="#왜" class="headerlink" title="왜?"></a>왜?</h2><p>스프링 부트 애플리케이션을 백그라운드 프로세스로 실행했다면 프로세스를 종료할 때 <code>PID(Process Identifier)</code>를 알아야 한다. 쉽게는 <code>ps -ef|grep java</code> 와 같은 명령어로 직접 PID를 확인하여 <code>kill</code> 명령어로 프로세스를 종료할 수 있지만 스프링 부트 애플리케이션의 재시작 자동화를 위해서는 다른 방법이 필요했다.</p><p>그래서 PID가 적혀있는 파일이 필요하고 스프링 부트에서는 PID 파일을 생성하도록 간단하게 설정할 수 있다.</p><h2 id="어떻게"><a href="#어떻게" class="headerlink" title="어떻게?"></a>어떻게?</h2><p><code>application.yml</code>에 아래와 같이 PID 파일 생성 경로를 지정한다.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  pid:</span></span><br><span class="line"><span class="attr">    file:</span> <span class="string">/home/ubuntu/test-app/test-app.pid</span> <span class="comment"># PID 파일 생성 경로 지정</span></span><br></pre></td></tr></table></figure><p><code>@SpringBootApplication</code> 어노테이션을 적용한 클래스의 <code>main()</code> 메서드에서 <code>SpringApplication</code> 객체를 생성 후 <code>addListeners()</code> 메서드를 통해 다음과 같이 <code>ApplicationPidFileWriter</code>를 설정해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(Application.class);</span><br><span class="line">    app.addListeners(<span class="keyword">new</span> ApplicationPidFileWriter()); <span class="comment">// ApplicationPidFileWriter 설정</span></span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지정한 경로에 PID 파일이 생성되는지 확인하면 끝!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;왜&quot;&gt;&lt;a href=&quot;#왜&quot; class=&quot;headerlink&quot; title=&quot;왜?&quot;&gt;&lt;/a&gt;왜?&lt;/h2&gt;&lt;p&gt;스프링 부트 애플리케이션을 백그라운드 프로세스로 실행했다면 프로세스를 종료할 때 &lt;code&gt;PID(Process Identifie
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://jheloper.github.io/tags/Spring/"/>
    
      <category term="PID" scheme="https://jheloper.github.io/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>JPA(Java Persistence API) 03 - 엔티티</title>
    <link href="https://jheloper.github.io/2019/05/jpa-03-entity/"/>
    <id>https://jheloper.github.io/2019/05/jpa-03-entity/</id>
    <published>2019-05-17T14:05:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="데이터베이스-스키마-자동-생성"><a href="#데이터베이스-스키마-자동-생성" class="headerlink" title="데이터베이스 스키마 자동 생성"></a>데이터베이스 스키마 자동 생성</h2><p><code>persistence.xml</code>에 <code>hibernate.hbm2ddl.auto</code> 속성을 추가하여 애플리케이션 실행 시점에 데이터베이스 스키마를 자동 생성하는 기능을 활성화할 수 있다.</p><p>자동으로 생성되는 DDL은 지정한 데이터베이스 방언에 따라 달라진다.</p><p>스키마 자동 생성 기능은 개발자가 스키마를 직접 생성하는 수고를 덜 수 있으나 <strong>운영 환경에서 사용하는 것은 추천하지 않고 개발 환경에서 사용하거나 엔티티와 테이블 매핑 참고 정도로 사용하는 것을 권장</strong>한다.</p><p><code>hibernate.hbm2ddl.auto</code> 속성에 지정할 수 있는 옵션은 아래와 같다.</p><ul><li><code>create</code> : 기존 테이블을 삭제하고 새로 생성한다.</li><li><code>create-drop</code> : create 속성 + 애플리케이션 종료 시 생성한 DDL을 제거한다.</li><li><code>update</code> : 테이블과 엔티티 매핑 정보를 비교해서 업데이트한다.</li><li><code>validate</code> : 테이블과 엔티티 매핑 정보를 비교해서 다른 경우 경고하며 애플리케이션을 실행하지 않는다.</li><li><code>none</code> : 데이터베이스 스키마 자동 생성 기능을 사용하지 않는다.</li></ul><p>JPA 2.1부터 스키마 자동 생성 기능을 표준으로 지원하는데 <code>javax.persistence.schema-generation.database.action</code> 속성에 <code>none</code>, <code>create</code>, <code>drop-and-create</code>, <code>drop</code> 중 하나의 옵션을 지정하면 된다. <code>hibernate.hbm2ddl.auto</code> 속성의 <code>update</code>, <code>validate</code> 옵션은 지원하지 않는다.</p><p><code>hibernate.ejb.naming_strategy</code> 속성으로 이름 매핑 전략을 바꿀 수 있다. 기본은 엔티티 클래스 이름이나 필드 이름을 그대로 사용하지만 <code>org.hibernate.cfg.ImproveNamingStrategy</code> 클래스를 지정하면 카멜 표기법으로 선언한 이름을 언더스코어 표기법으로 매핑한다.</p><h2 id="DDL-생성"><a href="#DDL-생성" class="headerlink" title="DDL 생성"></a>DDL 생성</h2><p><code>@Table</code>의 <code>uniqueConstraints</code> 속성이나 <code>@Column</code>의 <code>nullable</code>, <code>length</code>와 같은 속성은 스키마 자동 생성 시에만 사용된다. 즉 <strong>자동으로 생성되는 DDL에 적용되며, 직접 DDL을 만드는 경우 사용할 필요가 없으나 엔티티의 제약 조건 명시라는 측면에서 장점</strong>이 있다.</p><h2 id="객체와-테이블-매핑"><a href="#객체와-테이블-매핑" class="headerlink" title="객체와 테이블 매핑"></a>객체와 테이블 매핑</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p>데이터베이스 테이블과 매핑할 엔티티 클래스는 반드시 <code>@Entity</code> 어노테이션을 붙여야 한다. <code>name</code> 속성을 통해 엔티티 이름을 지정할 수 있다. 보통 기본 값인 클래스 이름을 사용하나 다른 패키지에 같은 클래스 이름을 가진 엔티티 클래스가 있다면 이름을 지정해서 충돌을 피해야 한다.</p><p>객체와 테이블 매핑 시 주의사항은 아래와 같다.</p><ul><li>기본 생성자 필수.</li><li>final 클래스, enum, 인터페이스, 내부 클래스는 사용할 수 없다.</li><li>저장할 필드에 final을 사용하면 안 된다.</li></ul><h3 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h3><p>엔티티와 매핑할 데이터베이스 테이블을 지정한다. 생략하면 엔티티 이름을 테이블 이름으로 사용한다.</p><ul><li><code>name</code> : 매핑할 테이블 이름 지정. 기본값은 엔티티 이름이다.</li><li><code>catalog</code> : 카탈로그 기능이 있는 데이터베이스에서 카탈로그 매핑.</li><li><code>schema</code> : 스키마 기능이 있는 데이터베이스에서 스키마 매핑.</li><li><code>uniqueConstraints(DDL)</code> : DDL 생성 시 유니크 제약조건 생성. 2개 이상의 복합 유니크 제약조건도 생성 가능. 해당 속성은 스키마 자동 생성 기능을 사용하여 DDL 생성 시에만 사용된다.</li></ul><h2 id="필드와-컬럼-매핑"><a href="#필드와-컬럼-매핑" class="headerlink" title="필드와 컬럼 매핑"></a>필드와 컬럼 매핑</h2><h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>객체 필드를 테이블 컬럼과 매핑한다.</p><ul><li><code>name</code> : 필드와 매핑할 테이블의 컬럼명을 지정한다. 기본 값은 엔티티의 필드 이름이다.</li><li><code>insertable</code> : 엔티티 저장 시 해당 필드 저장 여부를 지정한다. 기본 값은 true이다.</li><li><code>updatable</code> : 엔티티 수정 시 해당 필드 수정 여부를 지정한다. 기본 값은 true이다.</li><li><code>table</code> : 하나의 엔티티를 2개 이상의 테이블과 매핑 시 사용한다. 지정한 필드와 매핑할 테이블을 지정한다. 기본 값은 현재 엔티티가 매핑된 테이블이다.</li><li><code>nullable(DDL)</code> : null 값 허용 여부를 지정한다. 기본 값은 true이다.</li><li><code>unique(DDL)</code> : 해당 필드와 매핑되는 컬럼 1개에 대한 유니크 제약조건을 걸 때 사용한다.</li><li><code>columnDefinition(DDL)</code> : 데이터베이스 컬럼 정의를 직접 지정한다.</li><li><code>length(DDL)</code> : 문자 길이 제약조건을 지정한다. <code>String</code> 타입에만 사용하며 기본 값은 255이다.</li><li><code>precision</code>, <code>scale(DDL)</code> : <code>BigDecimal</code> 또는 <code>BigInteger</code> 타입에서 사용하며 precision은 소수점을 포함한 전체 자릿수, scale은 소수 자릿수를 지정한다. 기본 값은 precision은 19, scale은 2이다.</li></ul><h3 id="Enumerated"><a href="#Enumerated" class="headerlink" title="@Enumerated"></a>@Enumerated</h3><p>자바의 enum 타입을 매핑 시 사용한다. <code>value</code> 속성에 <code>EnumType</code> enum을 사용하여 <strong>enum 순서 기준으로 필드에 값을 저장할 것인지, enum 이름 기준으로 필드에 값을 저장할 것인지 지정</strong>할 수 있다.</p><ul><li><code>EnumType.ORDINAL</code> : enum 순서 기준으로 필드 값 지정. 0부터 시작한다. 장점으로는 저장되는 데이터 크기가 비교적 작다는 것이고 단점은 enum의 순서가 바뀔 경우 기존에 저장된 값을 수동으로 변경해야 한다는 것이다.</li><li><code>EnumType.STRING</code> : enum 이름 기준으로 필드 값 지정. 장점으로는 enum의 순서가 바뀌어도 기존에 저장된 값에 영향이 없다는 것이고 단점은 저장되는 데이터 크기가 비교적 크다는 것이다.</li></ul><h3 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h3><p>자바의 날짜 타입(<code>java.util.Date</code>, <code>java.util.Calendar</code>)을 매핑 시 사용한다. <code>value</code> 속성에 <code>TemporalType</code> enum을 사용하여 필드의 날짜 타입과 데이터베이스 타입 중 어떤 타입을 매핑할 것인지 지정할 수 있다.</p><ul><li><code>TemporalType.DATE</code> : 날짜, 데이터베이스 <code>date</code> 타입과 매핑된다.</li><li><code>TemporalType.TIME</code> : 시간, 데이터베이스 <code>time</code> 타입과 매핑된다.</li><li><code>TemporalType.TIMESTAMP</code> : 날짜와 시간, 데이터베이스 <code>timestamp</code> 타입과 매핑된다. MySQL의 경우 <code>datetime</code> 타입과 매핑된다.</li></ul><h3 id="Lob"><a href="#Lob" class="headerlink" title="@Lob"></a>@Lob</h3><p>데이터베이스 <code>BLOB(Binary Large Object)</code>, <code>CLOB(Character Large Object)</code> 타입과 매핑 시 사용한다. 매핑하는 필드 타입이 문자면 CLOB, 나머지는 BLOB으로 매핑한다.</p><h3 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h3><p>해당 필드를 데이터베이스와 매핑하지 않을 때 사용한다. 보통 객체에 임시로 어떤 값을 보관하고 싶을 때 사용한다.</p><h3 id="Access"><a href="#Access" class="headerlink" title="@Access"></a>@Access</h3><p>엔티티 데이터에 접근하는 방식을 지정한다. </p><p>2가지 접근 방식이 있으며 <code>AccessType</code> enum을 사용하여 지정한다.</p><ul><li><code>AccessType.FIELD</code> : 필드 접근 방식. 필드에 직접 접근하며 필드 접근 제어자가 private이어도 접근할 수 있다.</li><li><code>AccessType.PROPERTY</code> : 프로퍼티 접근 방식. <code>Getter</code>를 사용하여 접근한다.</li></ul><p><code>@Access</code>를 설정하지 않을 경우 <code>@Id</code>의 위치에 따라 접근 방식이 지정된다. <code>@Id</code> 어노테이션이 객체의 필드에 적용되어 있는 경우 필드 접근 방식, 객체 필드의 <code>Getter</code> 메서드에 적용되어 있는 경우 프로퍼티 접근 방식으로 지정되며 2가지 접근 방식을 혼합해서 사용할 수 있다.</p><h2 id="기본-키"><a href="#기본-키" class="headerlink" title="기본 키"></a>기본 키</h2><p><code>@Id</code> 어노테이션을 사용하여 기본 키를 지정할 수 있다.</p><p>데이터베이스에 따라 기본 키 생성 방식이 다를 수 있는데, <code>@GeneratedValue</code> 어노테이션의 <code>strategy</code> 속성에 <code>GenerationType</code> enum 클래스를 사용하여 기본 키 생성 전략을 지정할 수 있다.</p><p>JPA에서 제공하는 데이터베이스 기본 키 생성 전략은 아래와 같다.</p><ul><li>직접 할당 : 기본 키를 직접 할당한다.</li><li>자동 생성 : 대리 키 사용 방식.<ul><li><code>IDENTITY</code> : 기본 키 생성을 데이터베이스에 위임한다.</li><li><code>SEQUENCE</code> : 데이터베이스 시퀀스를 사용하여 기본 키를 할당한다.</li><li><code>TABLE</code> : 기본 키 테이블을 사용하여 기본 키를 할당한다.</li></ul></li></ul><p><code>persistence.xml</code>에 <code>hibernate.id.new_generator_mappings</code> 속성을 true 값으로 지정해야 한다. 하이버네이트에서 더 효과적이고 JPA 규격에 맞는 새로운 키 생성 전략을 개발했으나 하위 버전과의 호환성 유지를 위해 기본적으로 비활성화 되도록 false 값이 지정되어 있다.</p><h3 id="직접-할당-전략"><a href="#직접-할당-전략" class="headerlink" title="직접 할당 전략"></a>직접 할당 전략</h3><p>코드 상에서 기본 키 필드에 직접 값을 할당한다.</p><h3 id="IDENTITY-전략"><a href="#IDENTITY-전략" class="headerlink" title="IDENTITY 전략"></a>IDENTITY 전략</h3><p>기본 키 생성을 데이터베이스에 위임하는 전략. 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용한다.</p><p>데이터를 데이터베이스에 INSERT한 후에 기본 키 값을 조회할 수 있기에 엔티티에 식별자 값을 할당하려면 추가로 데이터베이스를 조회해야 한다. <code>JDBC3</code>에 추가된 <code>Statement.getGeneratedKeys()</code>를 사용하면 데이터 저장과 동시에 생성된 기본 키 값을 얻어올 수 있으며 하이버네이트는 이 메서드를 사용해서 데이터베이스와 한 번만 통신한다.</p><p>엔티티가 영속 상태가 되려면 식별자가 반드시 필요하기 때문에 IDENTITY 전략을 사용할 경우 엔티티 매니저의 <code>persist()</code>를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다. 즉 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다는 의미이다.</p><h3 id="SEQUENCE-전략"><a href="#SEQUENCE-전략" class="headerlink" title="SEQUENCE 전략"></a>SEQUENCE 전략</h3><p>데이터베이스 시퀀스는 유일 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트이며 SEQUENCE 전략은 이 시퀀스를 사용해서 기본 키를 생성하는 전략이다.</p><p>주로 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용한다.</p><p>먼저 데이터베이스에 시퀀스를 생성해야 하며, <code>@SequenceGenerator</code>를 사용해서 시퀀스 생성기를 등록해야 한다. <code>@SequenceGenerator</code>의 속성은 아래와 같다.</p><ul><li><code>name</code> : 시퀀스 생성기 이름을 지정한다. 필수.</li><li><code>sequenceName</code> : 매핑할 데이터베이스 시퀀스 이름을 지정한다. 기본 값은 JPA 구현체가 정의하며 하이버네이트의 경우 <code>hibernate_sequence</code>이다.</li><li><code>initialValue</code> : 초기 값을 지정한다. 기본 값은 1.</li><li><code>allocationSize</code> : 시퀀스 한 번 호출에 증가하는 수를 지정한다. 성능 최적화와 관련 있으며 기본 값은 50.</li><li><code>catalog</code>, <code>schema</code> : 데이터베이스 카탈로그, 스키마 이름을 지정한다.</li></ul><p>SEQUENCE 전략은 엔티티 매니저의 <code>persist()</code> 호출 시 데이터베이스 시퀀스를 사용해서 식별자를 조회한 후, 조회한 식별자를 엔티티에 할당하고 엔티티를 영속성 컨텍스트에 저장한다. 이후 플러시가 발생하면 엔티티를 데이터베이스에 저장한다.</p><p>JPA는 시퀀스 접근 횟수를 최적화하기 위해 시퀀스 생성기의 <code>allocationSize</code> 속성을 사용한다. <code>allocationSize</code> 속성에 지정된 값만큼 한 번에 데이터베이스의 시퀀스 값을 증가시키고, 그만큼의 시퀀스 값을 메모리에 저장해두며, 메모리에 저장된 시퀀스 값이 있으면 데이터베이스를 조회하지 않고 메모리의 시퀀스 값으로 엔티티의 식별자를 할당한다. 이 방법은 데이터베이스에 시퀀스 값을 조회하기 위한 접근 횟수를 줄일 수 있고, 시퀀스 값을 선점하므로 여러 JVM에서 동시에 접근해서 시퀀스를 사용해도 값이 충돌하지 않는 장점이 있으나 한 번에 증가하는 시퀀스 값이 많을 수 있다는 점을 염두하여야 한다.</p><h3 id="TABLE-전략"><a href="#TABLE-전략" class="headerlink" title="TABLE 전략"></a>TABLE 전략</h3><p>TABLE 전략은 키 생성 전용 테이블을 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스처럼 사용하는 전략이다. 이 전략은 테이블을 사용하므로 모든 데이터베이스에 적용할 수 있다.</p><p>먼저 키 생성 전용 테이블을 생성해야 한다. 기본적으로 <code>sequence_name</code> 컬럼을 시퀀스 이름용 컬럼, <code>next_val</code> 컬럼을 시퀀스 값용 컬럼으로 사용한다. 필요하면 컬럼명을 변경할 수 있다.</p><p><code>@TableGenerator</code>를 사용해서 테이블 키 생성기를 등록하고 키 생성 전용 테이블과 매핑한다.</p><ul><li><code>name</code> : 테이블 키 생성기 이름을 지정한다. 필수.</li><li><code>table</code> : 키 생성 전용 테이블을 지정한다. 기본 값은 <code>hibernate_sequences</code>이다.</li><li><code>pkColumnName</code> : 시퀀스 이름 컬럼명을 지정한다. 기본 값은 <code>sequence_name</code>이다.</li><li><code>valueColumnName</code> : 시퀀스 값 컬럼명을 지정한다. 기본 값은 <code>next_val</code>이다.</li><li><code>pkColumnValue</code> : 키로 사용할 값을 지정한다. 기본 값으로 엔티티 이름이 지정된다.</li><li><code>initialValue</code> : 초기 값을 지정한다. 마지막에 생성된 값 기준.</li><li><code>allocationSize</code> : 시퀀스 한 번 호출에 증가하는 수를 지정한다. 시퀀스 생성기와 마찬가지로 성능 최적화에 관련 있으며 기본 값은 50.</li><li><code>catalog</code>, <code>schema</code> : 데이터베이스 카탈로그, 스키마 이름을 지정한다.</li><li><code>uniqueConstraints(DDL)</code> : 유니크 제약 조건을 지정한다.</li></ul><p>TABLE 전략은 키 생성 전용 테이블을 조회하고, 값을 증가시키는 동작을 실행하기 때문에 SEQUENCE 전략과 비교하면 1번 더 데이터베이스와 통신하는 단점이 있다. 이 전략 역시 SEQUECE 전략과 마찬가지로 <code>allocationSize</code> 속성을 사용하여 최적화할 수 있으며 방법은 SEQUENCE 전략과 동일하다.</p><h3 id="AUTO-전략"><a href="#AUTO-전략" class="headerlink" title="AUTO 전략"></a>AUTO 전략</h3><p>선택한 데이터베이스 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택하는 전략. <code>@GeneratedValue</code> 어노테이션 <code>strategy</code> 속성의 기본 값이다.</p><p>보통 아직 키 생성 전략이 확정되지 않은 개발 단계에서 사용한다.</p><blockquote><p>위 내용은 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>를 읽으며 개인적으로 요약 및 정리하는 내용이다.<br>자세한 내용이 알고 싶으면 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>을 직접 읽어보길 추천한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;데이터베이스-스키마-자동-생성&quot;&gt;&lt;a href=&quot;#데이터베이스-스키마-자동-생성&quot; class=&quot;headerlink&quot; title=&quot;데이터베이스 스키마 자동 생성&quot;&gt;&lt;/a&gt;데이터베이스 스키마 자동 생성&lt;/h2&gt;&lt;p&gt;&lt;code&gt;persiste
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://jheloper.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://jheloper.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>JPA(Java Persistence API) 02 - 영속성</title>
    <link href="https://jheloper.github.io/2019/05/jpa-02-persistence/"/>
    <id>https://jheloper.github.io/2019/05/jpa-02-persistence/</id>
    <published>2019-05-06T16:55:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="엔티티-매니저-팩토리-Entity-Manager-Factory"><a href="#엔티티-매니저-팩토리-Entity-Manager-Factory" class="headerlink" title="엔티티 매니저 팩토리(Entity Manager Factory)"></a>엔티티 매니저 팩토리(Entity Manager Factory)</h2><p>엔티티 매니저를 생성하는 객체. 엔티티 매니저 팩토리 생성 비용은 매우 크므로 데이터베이스 당 1개만 만들어서 애플리케이션 전체에서 공유하여 사용한다.</p><h2 id="엔티티-매니저-Entity-Manager"><a href="#엔티티-매니저-Entity-Manager" class="headerlink" title="엔티티 매니저(Entity Manager)"></a>엔티티 매니저(Entity Manager)</h2><p>엔티티를 관리하는 객체. 엔티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 매우 적다. 여러 스레드가 동시 접근해서 사용하면 문제가 발생하므로 스레드 간 공유는 안 된다.</p><p>데이터베이스 연결이 꼭 필요한 시점이 되어야 데이터베이스 커넥션을 획득하여 사용한다. 보통 트랜잭션 시작 시 데이터베이스 커넥션을 획득한다.</p><p>엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 저장하여 관리한다.</p><h2 id="영속성-Persistence"><a href="#영속성-Persistence" class="headerlink" title="영속성(Persistence)"></a>영속성(Persistence)</h2><p>어떤 상태가 계속되는(지속되는) 성질이라고 이해하면 된다.</p><h2 id="영속성-컨텍스트-Persistence-Context"><a href="#영속성-컨텍스트-Persistence-Context" class="headerlink" title="영속성 컨텍스트(Persistence Context)"></a>영속성 컨텍스트(Persistence Context)</h2><p>엔티티가 지속되는 컨텍스트(맥락, 또는 환경이라고도 할 수 있다). 논리적 개념에 가깝다.</p><p>엔티티 매니저를 생성할 때 영속성 컨텍스트가 함께 생성된다. 즉 1대1 관계라고 볼 수 있으나, 여러 엔티티 매니저가 동일한 영속성 컨텍스트에 접근할 수도 있다.</p><p>영속성 컨텍스트는 <em>1차 캐시</em>, <em>동일성 보장</em>, <em>트랜잭션을 지원하는 쓰기 지연</em>, <em>변경 감지</em>, <em>지연 로딩</em> 기능을 지원한다.</p><h2 id="엔티티의-상태"><a href="#엔티티의-상태" class="headerlink" title="엔티티의 상태"></a>엔티티의 상태</h2><ul><li>비영속(new/transient) : 영속성 컨텍스트와 관계 없는 상태.</li><li>영속(managed) : 영속성 컨텍스트에 의해 관리되는 상태.</li><li>준영속(detached) : 영속성 컨텍스트에 의해 관리되었다가 분리된 상태.</li><li>삭제(removed) : 엔티티가 영속성 컨텍스트와 데이터베이스에서 삭제된 상태.</li></ul><h2 id="1차-캐시"><a href="#1차-캐시" class="headerlink" title="1차 캐시"></a>1차 캐시</h2><p>영속성 컨텍스트 내부에 캐시가 존재하는데 이것을 <strong>1차 캐시</strong>라고 부른다. 영속 상태인 엔티티는 여기에 저장되며 영속성 컨텍스트를 통해 엔티티를 조회하면 <em>먼저 1차 캐시에서 찾고 없으면 데이터베이스에서 조회</em>한다. 이 때 데이터베이스에서 조회한 엔티티를 <em>1차 캐시에 저장하고 영속 상태로 만든 엔티티를 반환</em>한다. 이렇게 하여 다음에 해당 엔티티를 조회할 경우 1차 캐시에서 엔티티를 반환할 수 있게 한다.</p><p>쉽게 생각하면 영속성 컨텍스트 내부에 키와 값 쌍으로 이뤄진 맵이 하나 있는데 키는 <code>@Id</code> 어노테이션을 매핑한 식별자이고 값은 엔티티 인스턴스라고 생각하면 된다.</p><p>1차 캐시에서 엔티티를 조회하는 경우 동일 키의 인스턴스에 대해 동일성을 보장한다. 즉, 영속성 컨텍스트에서 영속 상태의 엔티티를 조회할 때 동일 키를 사용해서 여러 번 조회한 경우 동일한 인스턴스를 반환한다는 의미이다.</p><h2 id="트랜잭션을-지원하는-쓰기-지연-Transactional-write-behind"><a href="#트랜잭션을-지원하는-쓰기-지연-Transactional-write-behind" class="headerlink" title="트랜잭션을 지원하는 쓰기 지연(Transactional write-behind)"></a>트랜잭션을 지원하는 쓰기 지연(Transactional write-behind)</h2><p>엔티티 매니저는 트랜잭션 커밋 전까지 데이터베이스에 엔티티를 저장하지 않고 <strong>내부 쿼리 저장소(=쓰기 지연 SQL 저장소)</strong>에 SQL을 누적한다. 그리고 트랜잭션 커밋 시 내부 쿼리 저장소에 누적된 쿼리를 데이터베이스에 보내는데 이것은 <strong>트랜잭션을 지원하는 쓰기 지연</strong>이라고 한다.</p><p>트랜잭션을 지원하는 쓰기 지연이 가능한 이유는, <em>매번 SQL을 데이터베이스에 보내는 방식이나 내부 쿼리 저장소에 SQL을 누적했다가 트랜잭션 커밋 시 한꺼번에 SQL을 데이터베이스에 보내는 방식이나 결론적으로 같은 결과</em>이기 때문이다. 트랜잭션을 커밋하지 않으면 매번 SQL을 데이터베이스에 보내도 소용이 없으며, 트랜잭션 커밋 직전에만 데이터베이스에 SQL을 전달하면 전자나 후자나 같은 결과를 보여줘야 한다.</p><h2 id="변경-감지-Dirty-checking"><a href="#변경-감지-Dirty-checking" class="headerlink" title="변경 감지(Dirty checking)"></a>변경 감지(Dirty checking)</h2><p>JPA에서 엔티티 수정 후 트랜잭션 커밋 직전에 그 어떤 메서드도 호출할 필요가 없다. 엔티티 데이터만 변경했는데도 데이터베이스에 반영되는 이유는, <strong>엔티티의 변경사항을 자동으로 감지</strong>하는 <strong>변경 감지</strong> 기능이 있기 때문이다.</p><p>JPA에서 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 <strong>스냅샷(Snapshot)으로 복사해서 저장</strong>해둔다. 그리고 엔티티 매니저에서 플러시할 때 <strong>스냅샷과 현재 엔티티를 비교</strong>해서 엔티티의 변경사항을 감지한다.</p><p><em>변경 감지는 영속 상태의 엔티티에만 적용</em>되며 비영속, 준영속 상태의 엔티티는 변경사항이 있어도 변경 감지가 되지 않고 따라서 데이터베이스에 반영되지도 않는다.</p><p>JPA의 UPDATE SQL 생성 기본 전략은 <em>엔티티의 모든 필드를 업데이트</em>하는 것이다. 이런 전략을 채택하면 데이터베이스에 보내는 데이터 전송량이 증가하나 아래와 같은 장점이 있다.</p><ul><li>모든 필드를 사용하는 수정 쿼리는 항상 같기 때문에 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있다. 즉, 수정 쿼리의 재사용성 측면에서 이점이 있다.</li><li>데이터베이스에 동일 쿼리를 전송하면 데이터베이스는 이전에 파싱된 쿼리를 재사용할 수 있다.</li></ul><p>필요에 따라 수정된 필드에 대해서만 UPDATE SQL을 생성하는 전략을 선택할 수 있다. 하이버네이트의 <code>@DynamicUpdate</code> 어노테이션을 엔티티 클래스에 적용하면 된다. 데이터를 저장할 때 데이터가 존재하는 필드만으로 INSERT SQL을 생성하는 <code>@DynamicInsert</code> 어노테이션도 있다.</p><p>엔티티 삭제 역시 즉시 삭제하는 것이 아니라 삭제 쿼리가 쓰기 지연 SQL 저장소에 저장되고 트랜잭션 커밋 시 플러시가 호출되면 데이터베이스에 삭제 쿼리를 전달한다. 물론 영속성 컨텍스트에서는 엔티티 삭제 메서드인 <code>remove</code> 메서드를 호출한 순간부터 제거된 상태이므로 해당 엔티티를 재사용하지 말고 가비지 컬렉팅이 되도록 내버려 둘 것.</p><h2 id="플러시-Flush"><a href="#플러시-Flush" class="headerlink" title="플러시(Flush)"></a>플러시(Flush)</h2><p>트랜잭션 커밋 시 영속성 컨텍스트에 반영된 변경사항을 데이터베이스에 동기화한다. 이것을 <strong>플러시</strong>라고 한다. 플러시는 영속성 컨텍스트에 보관된 엔티티를 지우는 작업이 아님을 명심할 것.</p><p>영속성 컨텍스트를 플러시하는 방법은 다음과 같다.</p><ol><li>직접 호출</li><li>트랜잭션 커밋</li><li>JPQL 쿼리 실행</li></ol><p>JPQL 쿼리 실행 시 플러시가 동작하는 이유는, <em>JPQL 쿼리를 실행하는 시점에 영속성 컨텍스트의 변경사항이 적용되지 않으면 JPQL 쿼리의 결과가 영속성 컨텍스트와 동기화되지 않은 결과</em>가 되기 때문이다.</p><p>엔티티 매니저를 통해 플러시 모드를 지정할 수 있다. 엔티티 매니저의 <code>setFlushMode</code> 메서드를 사용하면 되며 파라미터로 <code>FlushModeType</code> Enum을 지정하면 된다.</p><ul><li><code>FlushModeType.AUTO</code> : 트랜잭션 커밋 또는 쿼리 실행 시 플러시(기본값).</li><li><code>FlushModeType.COMMIT</code> : 트랜잭션 커밋 시에만 플러시.</li></ul><h2 id="준영속"><a href="#준영속" class="headerlink" title="준영속"></a>준영속</h2><p>영속 상태에서 준영속 상태로 바꾸는 방법은 3가지가 있다.</p><ul><li><code>detach</code> : 특정 엔티티를 준영속 상태로 전환한다.</li><li><code>clear</code> : 영속성 컨텍스트 초기화. 해당 영속성 컨텍스트의 모든 엔티티가 준영속 상태로 전환된다.</li><li><code>close</code> : 영속성 컨텍스트 종료. 마찬가지로 해당 영속성 컨텍스트의 모든 엔티티가 준영속 상태로 전환된다.</li></ul><p>준영속 상태의 엔티티는 이전에 영속 상태였다가 준영속 상태가 된 엔티티이므로 식별자 값을 가지고 있다.</p><p>준영속 상태의 엔티티는 지연 로딩이 불가능하다.</p><h2 id="병합-merge"><a href="#병합-merge" class="headerlink" title="병합(merge)"></a>병합(merge)</h2><p>준영속 상태의 엔티티를 다시 영속 상태로 전환할 때 병합을 사용한다. <code>merge</code> 메서드는 준영속 상태의 엔티티를 파라미터로 받아서 새로운 영속 상태의 엔티티로 반환한다. 여기서 주의할 것은 <strong>파라미터로 넘긴 준영속 상태의 엔티티 자체가 영속 상태로 전환되는 것이 아니라, 해당 엔티티와 동일한 정보를 가진 영속 상태의 엔티티를 새로 만들어 반환해주기 때문에 반환받은 엔티티를 사용해야 한다</strong>는 것이다.</p><p>비영속 상태의 엔티티도 병합을 통해 영속 상태로 만들 수 있다. 병합은 준영속, 비영속을 신경 쓰지 않기에 <code>save or update</code> 기능을 수행할 수 있다.</p><blockquote><p>위 내용은 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>를 읽으며 개인적으로 요약 및 정리하는 내용이다.<br>자세한 내용이 알고 싶으면 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>을 직접 읽어보길 추천한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;엔티티-매니저-팩토리-Entity-Manager-Factory&quot;&gt;&lt;a href=&quot;#엔티티-매니저-팩토리-Entity-Manager-Factory&quot; class=&quot;headerlink&quot; title=&quot;엔티티 매니저 팩토리(Entity Manag
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://jheloper.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://jheloper.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>2019년 1분기 회고</title>
    <link href="https://jheloper.github.io/2019/04/retrospective-2019-q1/"/>
    <id>https://jheloper.github.io/2019/04/retrospective-2019-q1/</id>
    <published>2019-04-30T12:20:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019년-1분기-회고"><a href="#2019년-1분기-회고" class="headerlink" title="2019년 1분기 회고"></a>2019년 1분기 회고</h2><p>2019년도 어느새 4분의 1이 지났다. 이전에 했던 회고는 1년 단위의 회고였는데, 앞으로는 되도록 분기별로 회고를 하자고 마음 먹었기 때문에 이번에는 2019년도 1분기의 회고를 하고자 한다.</p><h2 id="회사"><a href="#회사" class="headerlink" title="회사"></a>회사</h2><h3 id="파트너-API-프로젝트"><a href="#파트너-API-프로젝트" class="headerlink" title="파트너 API 프로젝트"></a>파트너 API 프로젝트</h3><p>회사에서 파트너 업체들에게 회사의 서비스 기능을 제공해주는 <em>파트너 API</em>를 개발하기로 결정했고, 해당 프로젝트에 참여하여 설계 및 구현, 릴리즈까지 마쳤다. 물론 혼자서 이 모든 것을 진행한 것이 절대 아니고 좋은 동료들이 함께였다. 덕분에 프로젝트를 무사히 마칠 수 있었으나 아직 끝난 건 아니었다. 서비스 개발로 끝나는 것이 아니라 운영 및 관리도 해줘야 하니까. <strong>개발하고 릴리즈하는 것은 소프트웨어를 탄생하게 하는 것, 그리고 그 소프트웨어를 운영하면서 관리해주는 것이야말로 소프트웨어를 자라게 해주는 것</strong> 아닐까. 그런 점에서 보면 태어난 지 얼마 되지 않은 서비스라서 신경 써야 할 부분이 아직 많은 것이 사실이다.</p><p>이 프로젝트를 진행하는 과정에서 여러 가지 서비스들이 추가되었는데 <code>OAuth 2.0</code> 인증 방식을 도입한 인증 서비스, <code>Zuul API Gateway</code>를 사용한 게이트웨이 서비스, 상품 관련 비즈니스 로직을 가지고 있는 상품 서비스, 파트너 API 관련 기능을 가지고 있으며 <code>Swagger</code>를 통한 API 문서화 기능까지 포함된 파트너 API 서비스가 바로 그것이다.</p><p>이 과정에서 파트너 API의 전체적인 흐름과 구조, 서비스 간의 관계 등을 고민하면서 직접 설계했는데 <code>MSA</code>의 여러 가지 어려움을 느낄 수 있었다. 서비스 간에 인터페이스를 어떻게 하는 것이 좋을지, 공통된 인터페이스는 어떤 포맷으로 정해야 할지, 서비스가 많아짐에 따른 관리를 어떻게 할 것인지, 서비스 간 의존성은 어떻게 관리할 것인지 등등…</p><p>어쨌든 내가 직접적으로 구현한 것은 <code>Zuul API Gateway</code>를 사용한 게이트웨이 서비스와 파트너 API 서비스 중 이전에 구현했던 주문 서비스와 관련되어 있는 부분들, 공통 인터페이스 부분이었다. 그 외에 이전에 만들었던 주문 서비스에 필요한 기능들을 추가하는 업무까지 포함되어 꽤나 정신없이 바쁘게 움직였다. </p><p>파트너 API의 인터페이스와 더불어 각 서비스 간의 인터페이스를 설계하면서 좀 더 <code>RESTful</code>한 API를 만들고자 노력했지만 완벽하게 “이것이야말로 <code>REST API</code>다!”라고 자부할만큼은 아니었다. 사내 스터디를 하면서 읽었던 “REST API 디자인 규칙” 책에서 나온 여러 가지 디자인 규칙을 도입하긴 했지만 모두 해내기에는 역부족이었다. “완벽한 REST API란 정말 까다로운 것이구나”라는 생각이 들 정도였다. 이에 대한 자세한 내용은 별도로 포스팅 해야겠다.</p><p>또한 서비스들의 분산되어 있는 로그를 통합하여 모니터링하기 위해 <code>ELK</code> 스택 도입을 건의했고, 그 과정에서 환경 구축 일부를 지원했다. 사실 굳이 로그 통합 모니터링을 위해서 ELK 스택을 도입하는 것은 배보다 배꼽이 더 큰 것 아닐까, 라는 생각이 들기도 했는데 이번에 구축한 ELK 스택이 로그 통합 모니터링으로 끝나는 게 아닌, 서비스의 데이터를 수집하고 분석하는 용도로도 사용될 여지가 있다는 판단 하에 ELK 스택 도입을 추천했으며 결국 우리 시스템에도 ELK 스택이 도입되었다. 아직은 시스템 일부에서만 사용하고 있지만 앞으로 적극적으로 활용할 수 있으리라 기대하고 있다.</p><p>늘어나는 서비스에 대비해서 늘어나는 EC2 인스턴스를 줄이고자 컨테이너 환경 도입을 건의했고, 새로 입사한 동료가 구축한 <code>Rancher</code>라는 컨테이너 오케스트레이션 서비스를 이용해 일부 서비스의 컨테이너 환경을 구축해보았다. 지금은 프로덕션 환경만 기존과 같이 서비스 당 인스턴스 단위로 운영하고 있으며, 베타 환경과 테스트 환경과 같은 다른 환경은 컨테이너 환경으로 운영하고 있다. 컨테이너 오케스트레이션 서비스를 처음 사용해보는 것이라 색다른 경험이었는데 추후에 이러한 컨테이너 오케스트레이션 서비스 중에서 특히나 유명한 <code>Kubernetes</code>에 대해서 따로 공부해봐야겠다는 생각이 들었다.</p><p>API 문서화에는 <code>Swagger</code>를 사용했다. Swagger를 선택한 이유는 서비스의 코드가 변경될 때마다 API 문서의 내용도 함께 갱신해야 하는데, 이 과정을 최대한 효율적으로 진행하기 위해서였다. API 문서 중 인터페이스 내용만이라도 변경된 코드 내용이 자동으로 반영된다면, 그만큼 손이 덜 가지 않을까 싶었다. 그러나 Swagger 역시 한계가 있었기 때문에 꽤 많은 부분을 커스터마이징해서 사용했다.</p><p>여기서 또 하나 느꼈던 것은 바깥으로 공개되는 API를 만들 때에는 특히 신경 써야 할 부분이 많다는 점이었다. 문서화도 그렇고, 인터페이스도 최대한 직관적으로 정해야 했다. 개발 시간만큼 많이 투자했던 부분이 바로 이런 부분들이었다. 내가 아직 이런 영역에 대한 경험이 적고 주도해야 하는 입장으로 일한 경험이 많지 않아서 더더욱 어렵게 느껴지기도 했다. </p><h2 id="개인"><a href="#개인" class="headerlink" title="개인"></a>개인</h2><h3 id="독서"><a href="#독서" class="headerlink" title="독서"></a>독서</h3><p>2권의 책(“컴퓨터 과학이 여는 세계”, “REST API 디자인 규칙”)을 읽었으며 현재 3번째, 4번째 책을 읽고 있다. 동시에 여러 권의 책을 번갈아 읽는 편이 효율적이라고 느껴서 이 방법을 채택하고 있는데, 애초에 목표했던 1달에 1권 읽기는 벌써 지키지 못했지만 포기할 생각은 없다. 오히려 좀 더 독서에 시간을 들여서 다시금 목표를 따라잡을 생각이다. 지금 현재 읽고 있는 책은 “토비의 스프링 3.1 1권”, “자바 ORM 표준 JPA 프로그래밍”인데 최근에는 “자바 ORM 표준 JPA 프로그래밍”을 좀 더 집중해서 읽고 있다.</p><h3 id="블로깅"><a href="#블로깅" class="headerlink" title="블로깅"></a>블로깅</h3><p>일단 1달에 2개 정도의 포스팅을 했으며, <code>Hexo</code>로 블로그 플랫폼을 갈아탔다. 문제는 저번달인 3월에는 아무것도 올리지 못했다는 것. 변명하자면 3월이 가장 바빴는데, 위에 적은 파트너 API 프로젝트의 막바지 단계였기 때문에 포스트 작성 시간을 확보하지 못했었다. 그래서 대신 이번 4월, 5월에는 좀 더 포스트 작성에 신경 쓰기로 마음 먹었다.</p><h3 id="개인-스터디"><a href="#개인-스터디" class="headerlink" title="개인 스터디"></a>개인 스터디</h3><p>최근에 <code>Rust</code>와 <code>JPA</code>를 집중적으로 공부하고 있다. <code>Rust</code>는 워낙 개인적으로 관심있는 언어였기 때문에 “지금 아니면 언제 해보랴”라는 생각으로 <code>Rust Language Book</code>을 보면서 따라서 코딩해봤다.</p><p>JPA는 최근 회사에서 서비스를 개발하면서 중점적으로 파고 들만한 이유가 있었다. 일단 <code>ORM</code>을 엔터프라이즈 환경에서 사용하는 것은 처음이니만큼 부족한 점이 있었다. 거기에 최근 JPA로 개발하면서 “우리 서비스의 데이터베이스에 맞춰 ORM으로 풀어낼 때 어떻게 풀어내야 할 것인가”에 대해 고민하고 삽질할 기회가 많아졌고, 같이 일하는 동료들도 열심히 JPA를 공부하며 이런 문제들을 하나씩 해결하고 있어서 나 역시 발목을 붙잡는 입장이 되지 않도록 열심히 공부하고 있다.</p><h3 id="회고를-마치며"><a href="#회고를-마치며" class="headerlink" title="회고를 마치며"></a>회고를 마치며</h3><p>이 회고를 작성하고 있는 지금은 벌써 4월의 마지막 날이다. 이번 회고를 작성하면서 작년 한 해도 바쁘게 움직였지만 “올 해도 꽤나 파란만장하겠구나”라는 생각이 들었다. 거기에 더해서 앞으로 공부해야 할 목록들이 공부하면 할수록 오히려 늘고 있어서 약간의 압박감마저 느끼고 있다.</p><p>그래도 회고를 작성하면서 스스로가 어떤 면에서 발전하고 있는지 알 수 있어 뿌듯하기도 하고, “앞으로 이런 부분들은 더 발전해야겠다”라는 생각이 들어 동기부여에도 도움이 되는 듯 하다. 이번으로 회고가 끝나지 않도록, 그리고 스스로가 경험하고 해내는 것들이 기록이 되고 데이터가 될 수 있도록 틈틈이 정리하는 시간을 가져야겠다. 앞으로 남은 시간들도 힘내서 더 발전할 수 있도록, 비록 빠르지 않더라도 한 걸음씩 나아갈 수 있는 사람이 되도록!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019년-1분기-회고&quot;&gt;&lt;a href=&quot;#2019년-1분기-회고&quot; class=&quot;headerlink&quot; title=&quot;2019년 1분기 회고&quot;&gt;&lt;/a&gt;2019년 1분기 회고&lt;/h2&gt;&lt;p&gt;2019년도 어느새 4분의 1이 지났다. 이전에 했던 
      
    
    </summary>
    
    
      <category term="Retrospective" scheme="https://jheloper.github.io/tags/Retrospective/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github Pages + Codeship을 통한 블로그 CI/CD 자동화</title>
    <link href="https://jheloper.github.io/2019/04/hexo-ci-cd-with-codeship/"/>
    <id>https://jheloper.github.io/2019/04/hexo-ci-cd-with-codeship/</id>
    <published>2019-04-28T13:30:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="뭘-또-바꾸려고"><a href="#뭘-또-바꾸려고" class="headerlink" title="뭘 또 바꾸려고?"></a>뭘 또 바꾸려고?</h2><p>이전에 Docker Container에 NPM와 Hexo를 설치해서 사용하는 내용을 포스팅한 적이 있다.</p><p>그 포스팅의 내용처럼 컨테이너에 NPM, Hexo를 설치해서 Hexo 서버를 실행해서 결과물을 미리 보고, 문제 없으면 Hexo Deploy 기능을 실행해서 직접 배포하는 방식으로 블로그를 관리하고 있었다. 그런데 사실 번거로운 것이 몇 가지 있었다.</p><p>일단 컨테이너를 실행해야 헀고, 컨테이너에서 미리 Hexo를 띄워서 볼 수 있는 점은 좋았으나 배포를 직접 실행해야 한다는 점이었다.</p><p>“번거로워도 그냥 써야겠다”라는 마음으로 사용하고 있었는데 회사 동료가 추천해 준 방법이 있었다. 그것은 바로 <strong>CI/CD 자동화 서비스를 이용해서 원격 저장소에 올리면 자동으로 배포</strong>하는 방법. </p><p>미리 띄워서 보는 기능만 제외한다면, 굳이 로컬에서 직접 배포할 필요 없이 자동으로 CI/CD가 되는 그 방법이 더 편하겠다는 생각이 들었다.</p><p>그래서 동료가 추천해 준 방법으로 바꿔보기로 결심했다.</p><h2 id="Github-Pages로-사용할-정적-파일-저장소와-Hexo-저장소-생성하기"><a href="#Github-Pages로-사용할-정적-파일-저장소와-Hexo-저장소-생성하기" class="headerlink" title="Github Pages로 사용할 정적 파일 저장소와 Hexo 저장소 생성하기"></a>Github Pages로 사용할 정적 파일 저장소와 Hexo 저장소 생성하기</h2><p>먼저 지금까지 1개의 저장소로 관리하던 것을 2개의 저장소로 나누기로 결정했다. 1개는 <a href="https://pages.github.com/" target="_blank" rel="noopener"><code>Github Pages</code></a>에 올라갈 <strong>정적 파일 저장소</strong>, 다른 하나는 Hexo 코드가 올라가는 <strong>Hexo 저장소</strong>.</p><p>지금까지는 하나의 저장소를 사용하면서 역할에 따라 브랜치만 분리해서 사용했지만 아예 저장소를 분리하는 것으로 결정했다. 나 같은 경우 Hexo 저장소는 프라이빗 저장소로, Hexo에서 생성한 정적 파일 저장소는 퍼블릭 저장소로 만들었다.</p><h2 id="Hexo에-Git-Deploy-설정하기"><a href="#Hexo에-Git-Deploy-설정하기" class="headerlink" title="Hexo에 Git Deploy 설정하기"></a>Hexo에 Git Deploy 설정하기</h2><p>Hexo의 <code>_config.xml</code> 파일에 Git Deploy 기능을 아래와 같이 설정해야 한다. <code>repo</code> 속성에 기입하는 경로는 정적 파일 저장소로 설정하면 된다. 자세한 내용은 <a href="https://hexo.io/docs/deployment" target="_blank" rel="noopener">링크</a>를 참조할 것.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://__GITHUB_TOKEN__@github.com/username/username.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>유의할 점은 repo 속성에 정적 파일 저장소의 경로를 지정할 때 <code>__GITHUB_TOKEN__@</code> 부분을 반드시 넣어줘야한다는 것이다. 왜냐하면 저 부분이 아래에서 발급할 <em>Github Access Token 값으로 대체될 Placeholder 부분</em>이기 때문이다. </p><h2 id="Github-Access-Token-발급하기"><a href="#Github-Access-Token-발급하기" class="headerlink" title="Github Access Token 발급하기"></a>Github Access Token 발급하기</h2><p><em>Github의 Settings &gt; Developer Settings &gt; Personal access tokens</em>로 이동하여 토큰을 발급 받는다. 아래 화면에서 보이는 <code>Generate new token</code> 버튼을 클릭해서 발급 받을 수 있다.</p><p><img src="/images/github-personal-access-token.png" alt></p><p>여기서 발급한 토큰 값은 이 화면에서 확인하고 나서 다른 화면에서는 확인 불가능하므로 개인적으로 잘 관리해야 한다.</p><h2 id="Codeship-프로젝트-생성"><a href="#Codeship-프로젝트-생성" class="headerlink" title="Codeship 프로젝트 생성"></a>Codeship 프로젝트 생성</h2><p>CI/CD 서비스는 여러 가지 많긴 하지만 <a href="http://codeship.com/" target="_blank" rel="noopener"><code>Codeship</code></a>이라는 서비스를 사용하기로 결정했다. 특별한 이유는 없었고, 1달에 100회의 빌드를 무료로 제공해주는 데다가 UI가 괜찮았고 동료의 가장 처음 언급했던 서비스였기 때문이다.</p><p>일단 Codeship에 Github 계정으로 로그인하면 다음과 같은 화면이 나온다.</p><p><img src="/images/codeship-build-01.png" alt></p><p>여기서 먼저 해야할 것은 <strong>프로젝트를 생성하는 것</strong>. 상단 네비게이션 바에 위치한 <code>Projects</code>를 클릭한다. 그럼 다음과 같은 화면이 뜨는데 우측 상단의 <code>New Project</code> 버튼을 클릭하여 프로젝트를 생성해야 한다.</p><p><img src="/images/codeship-build-02.png" alt></p><p>아래와 같이 대표적인 원격 저장소 서비스 3가지 중 1개를 고르게 하는데, 아까 Github 계정으로 로그인하기도 했고 Github Pages로 호스팅하고 있으므로 Github을 고른다.</p><p><img src="/images/codeship-build-03.png" alt></p><p>다음은 <code>Github Organization</code>과 <code>Repository</code>를 고르면 된다. Organization은 본인의 계정을, Repository는 Hexo 저장소를 지정한다.</p><p><img src="/images/codeship-build-04.png" alt></p><p>아래와 같은 화면이 나오면 <code>Codeship Basic</code>을 선택하면 된다.</p><p><img src="/images/codeship-build-05.png" alt></p><h2 id="Codeship-프로젝트-CI-CD-설정"><a href="#Codeship-프로젝트-CI-CD-설정" class="headerlink" title="Codeship 프로젝트 CI/CD 설정"></a>Codeship 프로젝트 CI/CD 설정</h2><p>프로젝트를 생성했으면 이제 CI/CD 설정을 해야 한다. 여러 가지 설정들이 있지만 그 중에서 필요한 부분들만 골라서 해보자. 먼저 상단의 <code>Deploy</code>를 누르면 아래와 같은 화면이 나오는데 배포 트리거로 작동할 브랜치를 지정하자. 나는 master 브랜치로 지정했다. 지정 후 <code>Save Pipeline Settings</code> 버튼을 누른다.</p><p><img src="/images/codeship-build-06.png" alt></p><p>그럼 다음과 같은 화면이 나오는데 <code>Custom Script</code>를 선택한다.</p><p><img src="/images/codeship-build-07.png" alt></p><p>배포에 사용할 셸 스크립트를 작성하고 <code>Create Deployment</code> 버튼을 누르면 배포 설정은 끝난다.</p><p><img src="/images/codeship-build-08.png" alt></p><p>위의 화면에서 입력하는 스크립트 내용은 아래와 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli hexo-generator-sitemap --save <span class="comment"># 필요한 hexo 의존성 설치</span></span><br><span class="line">git config --global user.email <span class="string">"<span class="variable">$&#123;USER_EMAIL&#125;</span>"</span> <span class="comment"># Git user.email 설정</span></span><br><span class="line">git config --global user.name <span class="string">"<span class="variable">$&#123;USER_NAME&#125;</span>"</span> <span class="comment"># Git user.name 설정</span></span><br><span class="line">sed -i <span class="string">"s/__GITHUB_TOKEN__/<span class="variable">$&#123;GITHUB_TOKEN&#125;</span>/"</span> _config.yml <span class="comment"># _config.yml Github 저장소 접근 시 토큰 사용하도록 placeholder 토큰값으로 대체</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo d -g <span class="comment"># hexo 정적 파일 생성하여 설정대로 배포 실행</span></span><br></pre></td></tr></table></figure><p><code>Build Triggers</code>를 선택하여 master 브랜치의 빌드 트리거를 설정하고 <code>Save Configuration</code>을 클릭한다.</p><p><img src="/images/codeship-build-09.png" alt></p><p><code>Environment</code>를 선택하여 배포 스크립트에서 사용할 환경변수를 설정한다. 아래와 같이 3개의 환경변수를 설정하면 된다.</p><p><img src="/images/codeship-build-10.png" alt></p><p>여기까지 설정했으면 기본적인 설정은 끝났다. 이제 실제로 Hexo 저장소의 master 브랜치에 푸시해보자.</p><h2 id="Hexo-저장소에-푸시하여-CI-CD가-정상적으로-실행되는지-테스트하기"><a href="#Hexo-저장소에-푸시하여-CI-CD가-정상적으로-실행되는지-테스트하기" class="headerlink" title="Hexo 저장소에 푸시하여 CI/CD가 정상적으로 실행되는지 테스트하기"></a>Hexo 저장소에 푸시하여 CI/CD가 정상적으로 실행되는지 테스트하기</h2><p>Hexo 저장소에 푸시를 하면 Codeship의 빌드 트리거가 실행되고 빌드 및 배포가 성공하면 아래와 같은 화면이 보인다.</p><p><img src="/images/codeship-build-11.png" alt></p><p>배포가 정상적으로 됐는지 Github Pages에서 호스팅해주는 블로그로 들어가서 확인해보면 된다.</p><p>이렇게 하면 Hexo 저장소에 포스트를 추가한 커밋을 푸시하면 Codeship 빌드, 배포가 실행되어 정적 파일 저장소에 정적 파일들이 푸시되고, 그 내용대로 Github Pages에 호스팅되는 과정이 실행된다. 이렇게 바꿔보니 확실히 편한 점이 있어서 나처럼 Hexo 블로그를 로컬에서 수동으로 배포하고 있었던 분들에게는 적극 추천이다!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;뭘-또-바꾸려고&quot;&gt;&lt;a href=&quot;#뭘-또-바꾸려고&quot; class=&quot;headerlink&quot; title=&quot;뭘 또 바꾸려고?&quot;&gt;&lt;/a&gt;뭘 또 바꾸려고?&lt;/h2&gt;&lt;p&gt;이전에 Docker Container에 NPM와 Hexo를 설치해서 사용하는 내
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://jheloper.github.io/tags/Hexo/"/>
    
      <category term="CI/CD" scheme="https://jheloper.github.io/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>JPA(Java Persistence API) 01 - 개요</title>
    <link href="https://jheloper.github.io/2019/04/jpa-01-overview/"/>
    <id>https://jheloper.github.io/2019/04/jpa-01-overview/</id>
    <published>2019-04-26T11:00:00.000Z</published>
    <updated>2020-06-21T20:09:35.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>패러다임의 불일치. <strong>객체지향 프로그래밍과 관계형 데이터베이스의 패러다임은 서로 다르기 때문에 불일치 문제가 발생</strong>.</p><p>따라서 객체와 관계형 데이터베이스 사이의 불일치 문제를 해결해 주는 역할로 <code>ORM(Object-Relational Mapping)</code>이 필요하며, <code>JPA(Java Persistence API)</code>가 바로 이런 <code>ORM 프레임워크</code>.</p><p>국내에서 아직까지도 많이 사용되는 <code>MyBatis</code>는 ORM 프레임워크가 아닌 <code>SQL 매퍼</code>.</p><h2 id="예제-코드를-위해-필요한-의존성"><a href="#예제-코드를-위해-필요한-의존성" class="headerlink" title="예제 코드를 위해 필요한 의존성"></a>예제 코드를 위해 필요한 의존성</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.hibernate.javax.persistence'</span>, <span class="string">name:</span> <span class="string">'hibernate-jpa-2.1-api'</span>, <span class="string">version:</span> <span class="string">'1.0.2.Final'</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'org.hibernate'</span>, <span class="string">name:</span> <span class="string">'hibernate-core'</span>, <span class="string">version:</span> <span class="string">'5.4.2.Final'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 테스트용으로 H2 데이터베이스를 사용하기 위해서 필요</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.h2database'</span>, <span class="string">name:</span> <span class="string">'h2'</span>, <span class="string">version:</span> <span class="string">'1.4.199'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JPA-설정"><a href="#JPA-설정" class="headerlink" title="JPA 설정"></a>JPA 설정</h2><p><code>persistence.xml</code> : <code>JPA</code> 환경 설정 정보를 지정하는 XML 파일.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/persistence"</span> <span class="attr">version</span>=<span class="string">"2.1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">"jpa-playground"</span> <span class="attr">transaction-type</span>=<span class="string">"RESOURCE_LOCAL"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>personal.jpa.playground.Member<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">class</span>&gt;</span>personal.jpa.playground.Product<span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.driver"</span> <span class="attr">value</span>=<span class="string">"org.h2.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.user"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.password"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.jdbc.url"</span> <span class="attr">value</span>=<span class="string">"jdbc:h2:mem:test"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.dialect"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.dialect.H2Dialect"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span> <span class="attr">value</span>=<span class="string">"create-drop"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.use_sql_comments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.id.new_generator_mappings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>persistence-unit</code> 요소의 <code>transaction-type</code> 속성은 <code>RESOURCE_LOCAL</code>, <code>JTA</code> 2가지가 있다.</p><p><code>RESOURCE_LOCAL</code>로 설정하면 엔티티 매니저, 트랜잭션 등을 직접 관리해야 한다.</p><p><code>JTA</code>는 <code>Java Transaction API</code>의 줄임말로, 엔터프라이즈 환경에서 주로 사용하는데 직접 엔티티 매니저를 생성하지 않고 컨테이너가 대신 생성해서 넘겨주는 엔티티 매니저를 사용하며 트랜잭션 역시 컨테이너가 관리한다.</p><p>쉽게 생각하자면 엔티티 매니저를 직접 생성하고 트랜잭션을 직접 관리할 경우는 <code>RESOURCE_LOCAL</code>, 컨테이너가 관리할 것이라면 <code>JTA</code>로 지정하면 된다.</p><p>지금은 엔터프라이즈 환경에서 사용하는 코드를 만드는 것이 아니라 직접 엔티티 매니저를 생성하고 트랜잭션을 관리하는 코드를 작성할 것이기 때문에 <code>RESOURCE_LOCAL</code>로 지정한다.</p><h2 id="JPA-표준-속성"><a href="#JPA-표준-속성" class="headerlink" title="JPA 표준 속성"></a>JPA 표준 속성</h2><ul><li>javax.persistence.jdbc.driver : JDBC 드라이버.</li><li>javax.persistence.jdbc.user : 데이터베이스 계정 아이디.</li><li>javax.persistence.jdbc.password : 데이터베이스 계정 패스워드.</li><li>javax.persistence.jdbc.url : 데이터베이스 URL.</li></ul><h2 id="하이버네이트-관련-속성"><a href="#하이버네이트-관련-속성" class="headerlink" title="하이버네이트 관련 속성"></a>하이버네이트 관련 속성</h2><ul><li>hibernate.dialect : 데이터베이스 방언(dialect) 설정.</li><li>hibernate.show_sql : 하이버네이트가 실행한 SQL 출력.</li><li>hibernate.format_sql : SQL 출력 시 정렬하여 출력.</li><li>hibernate.use_sql_comments : SQL 출력 시 주석도 같이 출력.</li><li>hibernate.id.new_generator_mappings : JPA 표준 키 생성 전략 사용.</li><li>hibernate.hbm2ddl.auto : 애플리케이션 실행 시 데이터베이스 테이블 자동 생성.</li></ul><h2 id="엔티티-매니저-팩토리"><a href="#엔티티-매니저-팩토리" class="headerlink" title="엔티티 매니저 팩토리"></a>엔티티 매니저 팩토리</h2><p>엔티티 매니저를 생성하기 위한 팩토리 객체. <code>persistence.xml</code>에 지정된 설정 정보를 바탕으로 생성된다. 이 때 JPA 구현체에 따라 데이터베이스 커넥션 풀도 생성하므로 생성 비용이 큰 편이다. <code>스레드 안전(Thread-safe)</code>하게 구현되어 있고 생성 비용이 크므로 애플리케이션 전체에서 한 번만 생성하여 사용하는 것이 일반적이다.</p><h2 id="엔티티-매니저"><a href="#엔티티-매니저" class="headerlink" title="엔티티 매니저"></a>엔티티 매니저</h2><p>엔티티 매니저 팩토리에서 생성한다. 엔티티를 저장하거나 수정, 삭제, 조회 등 엔티티 관련 작업을 처리하는 역할의 객체다. 엔티티 매니저 내부에 데이터베이스 커넥션을 유지하면서 데이터베이스와 통신한다. 유의할 점으로는 엔티티 매니저가 <strong>데이터베이스 커넥션과 관계 있으므로 스레드 간에 공유하거나 재사용하면 안된다</strong>는 것. </p><h2 id="트랜잭션-시작-및-커밋-롤백"><a href="#트랜잭션-시작-및-커밋-롤백" class="headerlink" title="트랜잭션 시작 및 커밋, 롤백"></a>트랜잭션 시작 및 커밋, 롤백</h2><p>JPA를 사용하면 <strong>항상 트랜잭션 내에서 데이터를 변경해야 하며 트랜잭션 없이 데이터 변경 시 예외가 발생</strong>한다.</p><p>엔티티 매니저로부터 <code>EntityTransaction</code> 객체를 가져와 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line"></span><br><span class="line">    transaction.begin();</span><br><span class="line">    doSomething(entityManager);</span><br><span class="line">    transaction.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    transaction.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>begin()</code> : 트랜잭션 시작.</li><li><code>commit()</code> : 트랜잭션 커밋.</li><li><code>rollback()</code> : 트랜잭션 롤백.</li></ul><h2 id="엔티티-등록-persist"><a href="#엔티티-등록-persist" class="headerlink" title="엔티티 등록 : persist()"></a>엔티티 등록 : persist()</h2><p>엔티티를 삽입하는 INSERT SQL이 생성된다.</p><h2 id="엔티티-수정"><a href="#엔티티-수정" class="headerlink" title="엔티티 수정"></a>엔티티 수정</h2><p>엔티티 수정 후 수정 내용 반영에는 별도의 메서드 호출이 필요 없다. JPA는 어떤 엔티티가 변경되었는지 추적 가능하기 때문에 엔티티의 값만 변경하면 UPDATE SQL이 생성되어 데이터베이스에 반영된다.</p><h2 id="엔티티-삭제-remove"><a href="#엔티티-삭제-remove" class="headerlink" title="엔티티 삭제 : remove()"></a>엔티티 삭제 : remove()</h2><p>엔티티를 삭제하는 DELETE SQL이 생성된다.</p><h2 id="엔티티-단일-조회-find"><a href="#엔티티-단일-조회-find" class="headerlink" title="엔티티 단일 조회 : find()"></a>엔티티 단일 조회 : find()</h2><p>조회할 엔티티 타입과 식별자 값으로 엔티티 하나를 조회하는 SELECT SQL이 생성되어 조회한 결과 값으로 엔티티가 생성되어 반환된다.</p><h2 id="JPQL-Java-Persistence-Query-Language"><a href="#JPQL-Java-Persistence-Query-Language" class="headerlink" title="JPQL(Java Persistence Query Language)"></a>JPQL(Java Persistence Query Language)</h2><p>SQL을 추상화한 객체지향 쿼리 언어. SQL과 거의 유사한 문법을 가진다. 둘의 가장 큰 차이점은 어느 대상으로 질의하느냐, 인데 SQL이 데이터베이스의 테이블을 대상으로 질의하는 반면 JPQL은 엔티티 객체를 대상으로 질의한다.</p><p>예를 들어 엔티티 객체를 대상으로 특정 조건 검색하는 경우, 데이터베이스의 데이터를 전부 가져와서 엔티티 객체로 변경한 후 검색해야 하는데 대량의 데이터를 가진 데이터베이스의 경우 이것은 불가능한 일이다. 따라서 특정 조건으로 데이터베이스에서 필요한 데이터만 불러오기 위한 쿼리를 생성해야 하는데, 이 때 JPQL을 사용할 수 있다.</p><p>엔티티 매니저의 <code>createQuery()</code> 메서드를 사용하여 쿼리 객체를 생성하고 쿼리 객체의 <code>getResultList()</code> 메서드를 통해 쿼리에 해당하는 엔티티 객체들을 반환 받을 수 있다.</p><blockquote><p>위 내용은 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>를 읽으며 개인적으로 요약 및 정리하는 내용이다.<br>자세한 내용이 알고 싶으면 김영한님의 <code>자바 ORM 표준 JPA 프로그래밍</code>을 직접 읽어보길 추천한다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ORM&quot;&gt;&lt;a href=&quot;#ORM&quot; class=&quot;headerlink&quot; title=&quot;ORM&quot;&gt;&lt;/a&gt;ORM&lt;/h2&gt;&lt;p&gt;패러다임의 불일치. &lt;strong&gt;객체지향 프로그래밍과 관계형 데이터베이스의 패러다임은 서로 다르기 때문에 불일치 문제
      
    
    </summary>
    
    
      <category term="JPA" scheme="https://jheloper.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="https://jheloper.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo, 로컬에서 도커 컨테이너로 실행하기</title>
    <link href="https://jheloper.github.io/2019/02/run-hexo-with-docker/"/>
    <id>https://jheloper.github.io/2019/02/run-hexo-with-docker/</id>
    <published>2019-02-28T04:40:18.000Z</published>
    <updated>2020-06-21T20:09:35.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile-작성"><a href="#Dockerfile-작성" class="headerlink" title="Dockerfile 작성"></a>Dockerfile 작성</h2><p>먼저 <code>Dockerfile</code>을 작성한다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:lts</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /my-hexo</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /my-hexo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install hexo-cli -g &amp;&amp; npm install hexo-generator-sitemap --save</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [ <span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"hexo clean &amp; hexo server"</span> ]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">4000</span></span><br></pre></td></tr></table></figure><p>별다른 구성은 없다. 호스트에 있는 Hexo 디렉터리와 연결할 디렉터리를 생성하고, Hexo 실행에 필요한 <code>hexo-cli</code>와 <code>sitemap.xml</code> 생성에 필요한 <code>hexo-generator-sitemap</code>을 npm으로 설치. 그리고 컨테이너 실행 시 <code>hexo clean</code> 명령과 <code>hexo server</code> 명령을 자동으로 실행하도록 하고, 컨테이너의 포트는 4000번 포트를 노출시킨다, 정도?</p><h2 id="도커-이미지-빌드-컨테이너-run-스크립트-작성"><a href="#도커-이미지-빌드-컨테이너-run-스크립트-작성" class="headerlink" title="도커 이미지 빌드, 컨테이너 run 스크립트 작성"></a>도커 이미지 빌드, 컨테이너 run 스크립트 작성</h2><p>그리고 이제 도커 이미지를 빌드하고 컨테이너를 띄우면 되는데, 이마저도 귀찮으니 스크립트 파일로 만들자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">docker build -t my-hexo .</span><br></pre></td></tr></table></figure><p>위는 도커 이미지 빌드 파일을 실행하는 스크립트 내용이다. 별다른 내용은 없다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">docker stop my-hexo-container</span><br><span class="line">docker rm my-hexo-container</span><br><span class="line">docker run -it -d --name my-hexo-container -v ~/jheloper.github.io:/my-hexo -p 9000:4000 my-hexo:latest</span><br></pre></td></tr></table></figure><p>그리고 이것은 위에서 만든 이미지로 컨테이너를 실행시키는 스크립트 내용이다. 기존에 만약 Hexo 컨테이너가 있을 경우 멈추고 삭제하는 부분을 추가했기 때문에 Hexo 컨테이너가 멈춰있거나 존재하지 않으면 에러 메시지가 출력되나 신경 쓰지 않아도 된다.</p><p>유의할 것은 이 스크립트 파일들에 실행 권한을 주는 것. <code>chmod</code> 명령을 실행하여 실행 권한을 주면 된다.</p><h2 id="실제로-사용할-때는"><a href="#실제로-사용할-때는" class="headerlink" title="실제로 사용할 때는?"></a>실제로 사용할 때는?</h2><p>실제로 사용할 때는 다음과 같이 사용하면 된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 먼저 Dockerfile, build.sh, run.sh는 같은 디렉터리에 위치해야 하며 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 해당 디렉터리가 현재 워킹 디렉터리인 상태에서 실행해야 한다</span></span><br><span class="line"></span><br><span class="line">~ ./build.sh</span><br><span class="line">...도커 이미지 생성 관련 내용 출력...</span><br><span class="line">~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">my-hexo             latest              368241969ff0        1 minutes ago      918MB</span><br><span class="line">~ ./run.sh</span><br><span class="line">465f2422703a5aec2d4daaa7703a2480fb381e5740eaadcebbffeeb58d8a9ef4</span><br><span class="line">~ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">465f2422703a        my-hexo:latest      "/bin/bash -c 'hexo …"   11 seconds ago      Up 9 seconds        0.0.0.0:9000-&gt;4000/tcp   my-hexo-container</span><br></pre></td></tr></table></figure><p>도커 컨테이너 실행을 확인했으면 브라우저를 열어 <code>http://localhost:9000</code>으로 접속하여 Hexo가 정상적으로 띄워졌는지 확인한다. 이것으로 끝.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dockerfile-작성&quot;&gt;&lt;a href=&quot;#Dockerfile-작성&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile 작성&quot;&gt;&lt;/a&gt;Dockerfile 작성&lt;/h2&gt;&lt;p&gt;먼저 &lt;code&gt;Dockerfile&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://jheloper.github.io/tags/Docker/"/>
    
      <category term="Hexo" scheme="https://jheloper.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
